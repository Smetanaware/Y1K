<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stroj ƒçasu</title>
    
    <!-- Naƒçten√≠ level≈Ø -->
<script src="levels.js"></script>
    
    <style>
       * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #2a2a2a;
    overflow: hidden;
    touch-action: none;
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

#game-container {
    /* Fixn√≠ aspect ratio 1:2 (≈°√≠≈ôka:v√Ω≈°ka) */
    aspect-ratio: 1 / 2;
    
    /* Vypln√≠ obrazovku, ale nep≈ôes√°hne */
    width: 100vw;
    max-width: 50vh;  /* Max ≈°√≠≈ôka = 50% viewport height */
    height: 100vh;
    max-height: 200vw; /* Max v√Ω≈°ka = 200% viewport width */
    
    /* Vnit≈ôn√≠ layout */
    padding: 2vh;
    display: flex;
    flex-direction: column;
    gap: 1vh;
    
    /* Zaji≈°tƒõn√≠ ≈æe obsah se nevypr≈°√≠ */
    box-sizing: border-box;
    position: relative;
}

#target-row {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 5px;
}

.target-panel {
    clip-path: polygon(11.43% 0%, 88.57% 0%, 100% 8%, 100% 92%, 88.57% 100%, 11.43% 100%, 0% 92%, 0% 8%);
}

#timer-bar-container {
    width: 100%;
    height: 20px;
    background-color: #1a1a1a;
    //border-radius: 10px;
    overflow: hidden;
    margin-bottom: 5px;
}

#timer-bar {
    width: 0%;  /* Zaƒç√≠n√° pr√°zdn√° */
    height: 100%;
    background-color: #4FC3F7; /* Svƒõtle modr√° */
    transition: width 0.1s linear;
}

#game-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 5px;
    width: 100%;
}

.grid-cell {
    aspect-ratio: 0.7; /* 70:100 */
}

#add-button {
    width: 100%;
    height: 50px;
    background-color: #4a4a4a;
    color: white;
    font-size: 24px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    margin-top: 10px;
}

#add-button:hover {
    background-color: #5a5a5a;
}

#add-button:active {
    background-color: #3a3a3a;
}

/* Animace splnƒõn√≠ c√≠le */
.panel-brightening {
    filter: brightness(3) !important;
    transition: filter 0.1s ease-out;
}

.panel-fading {
    opacity: 0 !important;
    transition: opacity 0.1s ease-out;
}

.target-panel-appearing {
    filter: brightness(3);
    transition: filter 0.1s ease-out;
}


.panel-non-interactive {
    pointer-events: none !important;
}

/* Zelen√© segmenty pro splnƒõn√© c√≠lov√© panely */
.target-panel .segment {
    filter: brightness(1.5) hue-rotate(60deg) saturate(3) !important;
}

/* P≈ôechodov√° animace mezi levely */
#level-transition {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90vw;
    max-width: 45vh;
    aspect-ratio: 1 / 1.5;
    background-color: #2a2a2a; /* Tmavƒõ modr√° */
    opacity: 0;
    z-index: 2000;
    pointer-events: none;
    transition: opacity 0.3s ease-in-out;
}

#level-transition.fade-in {
    opacity: 1;
}

    </style>
</head>
<body>
    <div id="game-container">
        <!-- C√≠lov√Ω ≈ô√°dek -->
<div id="target-row">
    <div class="target-panel" id="target-0"></div>
    <div class="target-panel" id="target-1"></div>
    <div class="target-panel" id="target-2"></div>
    <div class="target-panel" id="target-3"></div>
</div>

<!-- ƒåasom√≠ra -->
<div id="timer-bar-container">
    <div id="timer-bar"></div>
</div>

<!-- Hern√≠ pole 5x5 -->
<div id="game-grid"></div>

<!-- Tlaƒç√≠tko + -->
<button id="add-button">+</button>
    </div>
    
<!-- P≈ôechodov√° animace mezi levely -->
<div id="level-transition" style="display: none;"></div>

    
    <script>
        // ========== KONSTANTY A KONFIGURACE ==========
const GRID_SIZE = 5; // Velikost m≈ô√≠≈æky (5x5)
const PANEL_RATIO = 70 / 100; // Pomƒõr stran panelu

// Standardn√≠ sedmisegmentov√Ω displej - mapov√°n√≠ segment≈Ø na bity
// Pozice: gfedcba (bit 6 a≈æ 0)
const SEGMENTS = {
    a: 0b0000001,
    b: 0b0000010,
    c: 0b0000100,
    d: 0b0001000,
    e: 0b0010000,
    f: 0b0100000,
    g: 0b1000000
};



// ========== HERN√ç STAV ==========
let gameState = {
    level: 1,
    grid: Array(GRID_SIZE * GRID_SIZE).fill(null),
    targetPanels: [],
    completedTargets: [false, false, false, false],
    panelPool: [],
    timerInterval: null,
    timerDuration: 5000,
    timerRemaining: 5000,
    isIntroSequence: false,
    petrifiedPositions: [],
    isRefilling: false,
    introInterval: null,      // Reference na intro interval
    refillInterval: null      // Reference na refill interval
};

// ========== INICIALIZACE ==========
console.log("Stroj ƒçasu - hern√≠ engine inicializov√°n");
console.log("Velikost m≈ô√≠≈æky:", GRID_SIZE, "x", GRID_SIZE);
console.log("C√≠lov√© panely pro level 1 (2025):", [
    DIGITS[2], DIGITS[0], DIGITS[2], DIGITS[5]
]);
// ========== VYKRESLOV√ÅN√ç PANEL≈Æ ==========

/**
 * Vytvo≈ô√≠ HTML element panelu s LED displejem
 * @param {number} segmentMask - 7-bitov√© ƒç√≠slo reprezentuj√≠c√≠ rozsv√≠cen√© segmenty
 * @returns {HTMLElement} -Div element s panelem
 */
function createPanelElement(segmentMask) {
    const panel = document.createElement('div');
    panel.className = 'led-panel';
    panel.style.position = 'relative';
    panel.style.width = '100%';
    panel.style.aspectRatio = PANEL_RATIO;
    
    // Pozad√≠ panelu
    const bg = document.createElement('img');
    bg.src = 'assets/panel_bg.svg';
    bg.style.position = 'absolute';
    bg.style.width = '100%';
    bg.style.height = '100%';
    bg.style.top = '0';
    bg.style.left = '0';
    panel.appendChild(bg);
    
    // P≈ôid√°n√≠ segment≈Ø podle masky
    const segmentNames = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
    segmentNames.forEach((name, index) => {
        const bitMask = 1 << index; // 2^index
        if (segmentMask & bitMask) { // Pokud je segment rozsv√≠cen√Ω
            const seg = document.createElement('img');
            seg.src = `assets/seg_${name}.svg`;
            seg.className = `segment seg-${name}`;
            seg.style.position = 'absolute';
            seg.style.width = '100%';
            seg.style.height = '100%';
            seg.style.top = '0';
            seg.style.left = '0';
            seg.style.pointerEvents = 'none';
            panel.appendChild(seg);
        }
    });
    
    // Ulo≈æen√≠ hodnoty segment≈Ø jako data atribut
    panel.dataset.segments = segmentMask;
    
    return panel;
}

// TEST: Vytvo≈ôen√≠ testovac√≠ho panelu s ƒç√≠slic√≠ "8" (v≈°echny segmenty)
console.log("Test: Vytv√°≈ôen√≠ panelu s ƒç√≠slic√≠ 8");
const testPanel = createPanelElement(DIGITS[8]);
console.log("Panel vytvo≈ôen:", testPanel);
// ========== VYKRESLOV√ÅN√ç M≈ò√ç≈ΩKY ==========

/**
 * Vykresl√≠ celou hern√≠ m≈ô√≠≈æku 5x5
 */
function renderGrid() {
    const gridElement = document.getElementById('game-grid');
    gridElement.innerHTML = ''; // Vyƒçist√≠ m≈ô√≠≈æku
    
    // Vytvo≈ôen√≠ 25 bunƒõk
    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.dataset.index = i;
        cell.style.backgroundColor = '#1a1a1a';
        cell.style.clipPath = 'polygon(11.43% 0%, 88.57% 0%, 100% 8%, 100% 92%, 88.57% 100%, 11.43% 100%, 0% 92%, 0% 8%)';
        //cell.style.borderRadius = '8px';
        cell.style.display = 'flex';
        cell.style.alignItems = 'center';
        cell.style.justifyContent = 'center';
        cell.style.position = 'relative';
        
        // Pokud je na t√©to pozici panel, vykresli ho
        if (gameState.grid[i] !== null) {
            const panel = createPanelElement(gameState.grid[i]);
            panel.style.width = '96%';
            panel.style.height = '96%';
            
            // Pokud je panel zkamenƒõl√Ω, aplikuj efekt
            if (isPetrified(i)) {
                panel.style.filter = 'grayscale(100%) sepia(100%) hue-rotate(-50deg) saturate(300%)';
                panel.style.opacity = '0.7';
                panel.classList.add('petrified');
            }
            
            cell.appendChild(panel);
        }
        
        gridElement.appendChild(cell);
    }
        attachGridListeners();
}

/**
 * P≈ôid√° panel na n√°hodnou volnou pozici v m≈ô√≠≈æce
 * @param {number} segmentMask - Hodnota panelu (7-bit)
 * @returns {boolean} - True pokud se poda≈ôilo p≈ôidat, false pokud je pole pln√©
 */
function addPanelToGrid(segmentMask) {
    // Najdi v≈°echny voln√© pozice
    const emptyPositions = [];
    for (let i = 0; i < gameState.grid.length; i++) {
        if (gameState.grid[i] === null) {
            emptyPositions.push(i);
        }
    }
    
    // Pokud nen√≠ ≈æ√°dn√° voln√° pozice, hra konƒç√≠
    if (emptyPositions.length === 0) {
        console.log("GAME OVER - pole je pln√©!");
        return false;
    }
    
    // Vyber n√°hodnou pozici
    const randomIndex = Math.floor(Math.random() * emptyPositions.length);
    const position = emptyPositions[randomIndex];
    
    // P≈ôidej panel na tuto pozici
    gameState.grid[position] = segmentMask;
    renderGrid();
    
    console.log(`Panel p≈ôid√°n na pozici ${position}, hodnota: ${segmentMask.toString(2)}`);
    return true;
}

// Inicializaƒçn√≠ vykreslen√≠ pr√°zdn√© m≈ô√≠≈æky
renderGrid();
console.log("M≈ô√≠≈æka 5x5 vykreslena");

// ========== VYKRESLOV√ÅN√ç C√çLOV√âHO ≈ò√ÅDKU ==========

/**
 * Vykresl√≠ c√≠lov√Ω ≈ô√°dek s panely
 */
function renderTargetRow() {
    for (let i = 0; i < 4; i++) {
        const targetElement = document.getElementById(`target-${i}`);
        targetElement.innerHTML = '';
        targetElement.style.width = '60px';
        targetElement.style.aspectRatio = PANEL_RATIO;
        targetElement.style.backgroundColor = '#1a1a1a';
        //targetElement.style.borderRadius = '8px';
        targetElement.style.display = 'flex';
        targetElement.style.alignItems = 'center';
        targetElement.style.justifyContent = 'center';
        targetElement.style.position = 'relative';
        
        // V≈ΩDY zobraz n√°hled c√≠lov√©ho panelu (≈°ed√Ω)
        const previewPanel = createPanelElement(gameState.targetPanels[i]);
        previewPanel.style.width = '95%';
        previewPanel.style.height = '96%';
        previewPanel.style.opacity = '0.3'; // ≈†ed√Ω n√°hled
        previewPanel.style.filter = 'grayscale(100%)'; // ƒåernob√≠l√Ω
        targetElement.appendChild(previewPanel);
        
        // Pokud je tento c√≠l splnƒõn, zobraz barevn√Ω panel P≈òES n√°hled
        if (gameState.completedTargets[i]) {
            const completedPanel = createPanelElement(gameState.targetPanels[i]);
            completedPanel.style.width = '90%';
            completedPanel.style.height = '90%';
            completedPanel.style.position = 'absolute';
            completedPanel.style.top = '50%';
            completedPanel.style.left = '50%';
            completedPanel.style.transform = 'translate(-50%, -50%)';
            targetElement.appendChild(completedPanel);
        }
    }
}

/**
 * √övodn√≠ sekvence - rychl√© p≈ôid√°n√≠ 4 panel≈Ø
 */
function playIntroSequence() {
    gameState.isIntroSequence = true;
    
    // Level 1 m√° pouze 2 panely, ostatn√≠ 4
    const panelCount = (gameState.level === 1) ? 2 : 4;
    
    // Zak√°zat tlaƒç√≠tko +
    const addButton = document.getElementById('add-button');
    addButton.disabled = true;
    addButton.style.opacity = '0.5';
    addButton.style.cursor = 'not-allowed';
    
    console.log(`√övodn√≠ sekvence - p≈ôid√°v√°m ${panelCount} panely...`);
    
    let count = 0;
    gameState.introInterval = setInterval(() => {
        if (count < panelCount) {
            // P≈ôidej panel z poolu
            if (gameState.panelPool.length > 0) {
                const panelValue = gameState.panelPool.shift();
                addPanelToGrid(panelValue);
                console.log(`√övodn√≠ panel ${count + 1}/${panelCount} p≈ôid√°n`);
                count++;
            }
        } else {
            // Konec √∫vodn√≠ sekvence
            // Konec √∫vodn√≠ sekvence
            clearInterval(gameState.introInterval);
            gameState.introInterval = null;
            gameState.isIntroSequence = false;
            
            // Povolit tlaƒç√≠tko +
            addButton.disabled = false;
            addButton.style.opacity = '1';
            addButton.style.cursor = 'pointer';
            
            console.log("√övodn√≠ sekvence dokonƒçena - spou≈°t√≠m ƒçasom√≠ru");
            
            // Odstra≈à POUZE zkamenƒõl√© osmiƒçky, kter√© byly pou≈æity ke splnƒõn√≠ c√≠l≈Ø
            // (tzn. osmiƒçka je v c√≠lech A byla oznaƒçena jako splnƒõn√° v fulfillPetrifiedEights)
            if (gameState.targetPanels.includes(0b1111111)) {
                // Spoƒç√≠tej, kolik osmiƒçek bylo oznaƒçeno jako splnƒõn√©
                const completedEightsCount = gameState.targetPanels.filter((panel, index) => 
                    panel === 0b1111111 && gameState.completedTargets[index]
                ).length;
                
                // Odstra≈à tolik zkamenƒõl√Ωch osmiƒçek, kolik jich bylo splnƒõno
                const petrifiedEights = gameState.petrifiedPositions.filter(pos => 
                    gameState.grid[pos] === 0b1111111
                );
                
                for (let i = 0; i < completedEightsCount && i < petrifiedEights.length; i++) {
                    const pos = petrifiedEights[i];
                    gameState.grid[pos] = null;
                    gameState.petrifiedPositions = gameState.petrifiedPositions.filter(p => p !== pos);
                    console.log(`üíé Zkamenƒõl√° osmiƒçka na pozici ${pos} zmizela (splnƒõn c√≠l)`);
                }
                
                if (completedEightsCount > 0) {
                    renderTargetRow();
                    renderGrid();
                }
            }
            
            
            // Teƒè spus≈• ƒçasom√≠ru
            startTimer();
        }
    }, 100); // Ka≈æd√Ωch 0.1 sekundy
}

/**
 * Spln√≠ zkamenƒõl√© osmiƒçky, pokud jsou v c√≠lech aktu√°ln√≠ho levelu
 * (Vol√° se P≈òED generov√°n√≠m poolu)
 */
function fulfillPetrifiedEights() {
    if (!gameState.targetPanels.includes(0b1111111)) {
        return; // V c√≠lech nen√≠ osmiƒçka
    }
    
    const petrifiedEightPositions = [...gameState.petrifiedPositions];
    
    petrifiedEightPositions.forEach(pos => {
        // Najdi prvn√≠ nesplnƒõn√Ω c√≠l s osmiƒçkou
        const targetIndex = gameState.targetPanels.findIndex((panel, index) => 
            panel === 0b1111111 && !gameState.completedTargets[index]
        );
        
        if (targetIndex !== -1) {
            // Oznaƒç jako splnƒõn√Ω (ale panel zat√≠m NEZMIZEL - zmiz√≠ a≈æ v √∫vodn√≠ sekvenci)
            gameState.completedTargets[targetIndex] = true;
            console.log(`üíé Zkamenƒõl√° osmiƒçka na pozici ${pos} p≈ôipravena ke splnƒõn√≠ c√≠le ${targetIndex}`);
        }
    });
}

/**
 * Inicializace levelu - nastav√≠ c√≠lov√© panely
 * @param {number} levelNumber - ƒå√≠slo levelu (1, 2, 3...)
 */
function initLevel(levelNumber) {
	
	// Zastav v≈°echny bƒõ≈æ√≠c√≠ intervaly (prevence duplicit p≈ôi p≈ôechodu level≈Ø)
    stopTimer();
    
    // Zastav intro interval, pokud bƒõ≈æ√≠
    if (gameState.introInterval) {
        clearInterval(gameState.introInterval);
        gameState.introInterval = null;
    }
    
    // Zastav refill interval, pokud bƒõ≈æ√≠
    if (gameState.refillInterval) {
        clearInterval(gameState.refillInterval);
        gameState.refillInterval = null;
    }
    
    gameState.isIntroSequence = false;
    gameState.isRefilling = false;
	
    // Najdi level v poli LEVELS
    const levelData = LEVELS.find(l => l.levelNumber === levelNumber);
    
    if (!levelData) {
        console.error(`Level ${levelNumber} nenalezen!`);
        return;
    }
    
    // Nastav hern√≠ stav podle dat levelu
    gameState.level = levelNumber;
    gameState.targetPanels = levelData.targetPanels;
    gameState.completedTargets = [false, false, false, false];
    gameState.timerDuration = levelData.timerDuration;
    gameState.timerRemaining = levelData.timerDuration;
    
    // Vyƒçisti m≈ô√≠≈æku, ale zachovej zkamenƒõl√© osmiƒçky
    const oldGrid = [...gameState.grid];
    gameState.grid = Array(GRID_SIZE * GRID_SIZE).fill(null);
    
    // P≈ôenes zkamenƒõl√© osmiƒçky do nov√© m≈ô√≠≈æky
    gameState.petrifiedPositions.forEach(pos => {
        gameState.grid[pos] = oldGrid[pos];
    });    
    console.log(`Level ${levelNumber} inicializov√°n: ${levelData.displayName}`);
    console.log(`ƒåasom√≠ra: ${levelData.timerDuration}ms`);
    console.log(`Povolen√© operace: ${levelData.allowedOperations.join(', ')}`);
    
    // NEJD≈ò√çV spl≈à zkamenƒõl√© osmiƒçky (pokud jsou v c√≠lech)
    fulfillPetrifiedEights();
    
    // PAK vygeneruj pool (u≈æ v√≠, kter√© c√≠le jsou splnƒõn√©)
    const allowedOps = levelData.allowedOperations;
    gameState.panelPool = generatePool(allowedOps);
    
    // Vykresli v≈°e
    renderGrid();
    renderTargetRow();
    
    // Spu≈°tƒõn√≠ √∫vodn√≠ sekvence (ƒçasom√≠ra se spust√≠ a≈æ po n√≠)
    playIntroSequence();
}

// Inicializace Level 1
initLevel(1);
console.log("C√≠lov√Ω ≈ô√°dek vykreslen");

// ========== OVL√ÅD√ÅN√ç TLAƒå√çTKA + ==========

/**
 * Obsluha kliknut√≠ na tlaƒç√≠tko +
 */
/**
 * Obsluha kliknut√≠ na tlaƒç√≠tko +
 */
function handleAddButton() {
	
	// Bƒõhem √∫vodn√≠ sekvence nelze p≈ôid√°vat panely
    if (gameState.isIntroSequence) {
        return;
    }
    
    // Pokud je pool pr√°zdn√Ω, vygeneruj nov√Ω
    if (gameState.panelPool.length === 0) {
        console.log("Pool pr√°zdn√Ω, generuji nov√Ω...");
        regeneratePool();
    }
    
    // Vezmi prvn√≠ panel z poolu
    const panelValue = gameState.panelPool.shift(); // Odebere prvn√≠ prvek
    
    console.log(`P≈ôid√°v√°m panel z poolu: ${panelValue.toString(2).padStart(7, '0')}`);
    console.log(`Zb√Ωv√° v poolu: ${gameState.panelPool.length} panel≈Ø`);
    
    // P≈ôidej panel na m≈ô√≠≈æku
    const success = addPanelToGrid(panelValue);
    
    if (!success) {
        alert("GAME OVER - pole je pln√©!");
        // TODO: zde bude reset hry
    }
    // Reset timeru p≈ôi manu√°ln√≠m p≈ôid√°n√≠
    resetTimer();
}

// Napojen√≠ tlaƒç√≠tka
document.getElementById('add-button').addEventListener('click', handleAddButton);

console.log("Tlaƒç√≠tko + napojeno");
console.log("=== HRA P≈òIPRAVENA K TESTOV√ÅN√ç ===");
console.log("Klikni na tlaƒç√≠tko + pro p≈ôid√°n√≠ testovac√≠ho panelu");

// ========== LOGICK√â OPERACE ==========

/**
 * NOT operace - invertuje v≈°echny segmenty panelu
 * @param {number} segmentMask - P≈Øvodn√≠ hodnota panelu
 * @returns {number} - Invertovan√° hodnota
 */
function notOperation(segmentMask) {
    // XOR s 0b1111111 (v≈°ech 7 bit≈Ø) = inverze
    return segmentMask ^ 0b1111111;
}

/**
 * OR operace - spoj√≠ dva panely (sjednocen√≠ rozsv√≠cen√Ωch segment≈Ø)
 * @param {number} mask1 - Prvn√≠ panel
 * @param {number} mask2 - Druh√Ω panel
 * @returns {number} - Spojen√Ω panel
 */
function orOperation(mask1, mask2) {
    return mask1 | mask2;
}

// TESTY logick√Ωch operac√≠
console.log("=== TEST LOGICK√ùCH OPERAC√ç ===");
console.log("NOT operace:");
console.log("  Vstup:  0b0000110 (bc) =", 0b0000110);
console.log("  V√Ωstup:", notOperation(0b0000110).toString(2).padStart(7, '0'));

console.log("OR operace:");
console.log("  Panel A: 0b0010101 (ace) =", 0b0010101);
console.log("  Panel B: 0b1000010 (bg) =", 0b1000010);
console.log("  V√Ωsledek:", orOperation(0b0010101, 0b1000010).toString(2).padStart(7, '0'), "(abceg)");
// ========== INTERAKCE: KLIKNUT√ç NA PANEL ==========

/**
 * Obsluha kliknut√≠ na panel - provede NOT operaci
 * @param {number} gridIndex - Index pozice v m≈ô√≠≈æce (0-24)
 */
 
 
 /**
 * Zkontroluje, zda je cel√° plocha pr√°zdn√° a p≈ô√≠padnƒõ dosype 4 panely
 */
function checkAndRefillGrid() {
    // Bƒõhem √∫vodn√≠ sekvence nebo dosyp√°n√≠ nekontroluj
    if (gameState.isIntroSequence || gameState.isRefilling) {
        return;
    }
    
    // Zkontroluj, zda jsou v≈°echny pozice pr√°zdn√© (kromƒõ zkamenƒõl√Ωch)
    const allEmpty = gameState.grid.every((value, index) => {
        return value === null || gameState.petrifiedPositions.includes(index);
    });
    
    if (allEmpty) {
        console.log("üîÑ Plocha pr√°zdn√° - dosyp√°v√°m 4 panely!");
        refillGrid();
    }
}

/**
 * Automaticky dosype 4 panely p≈ôi pr√°zdn√© plo≈°e
 */
function refillGrid() {
    gameState.isRefilling = true;
    
    // Level 1 m√° pouze 2 panely, ostatn√≠ 4
    const panelCount = (gameState.level === 1) ? 2 : 4;
    
    // Zastav ƒçasom√≠ru
    stopTimer();
    
    // Zak√°zat tlaƒç√≠tko +
    const addButton = document.getElementById('add-button');
    addButton.disabled = true;
    addButton.style.opacity = '0.5';
    addButton.style.cursor = 'not-allowed';
    
    console.log(`Dosyp√°v√°m ${panelCount} panely...`);
    
    let count = 0;
    gameState.refillInterval = setInterval(() => {
        if (count < panelCount) {
            // Pokud je pool pr√°zdn√Ω, vygeneruj nov√Ω
            if (gameState.panelPool.length === 0) {
                console.log("Pool pr√°zdn√Ω bƒõhem dosyp√°n√≠ - generuji nov√Ω...");
                regeneratePool();
            }
            
            // P≈ôidej panel z poolu
            if (gameState.panelPool.length > 0) {
                const panelValue = gameState.panelPool.shift();
                addPanelToGrid(panelValue);
                console.log(`Dosyp√°n√≠: panel ${count + 1}/${panelCount} p≈ôid√°n`);
                count++;
            }
        } else {
            // Konec dosyp√°n√≠
            // Konec dosyp√°n√≠
            clearInterval(gameState.refillInterval);
            gameState.refillInterval = null;
            gameState.isRefilling = false;
            
            // Povolit tlaƒç√≠tko +
            addButton.disabled = false;
            addButton.style.opacity = '1';
            addButton.style.cursor = 'pointer';
            
            console.log("Dosyp√°n√≠ dokonƒçeno - spou≈°t√≠m ƒçasom√≠ru");
            
            // Spus≈• ƒçasom√≠ru
            startTimer();
        }
    }, 100); // 0.1 sekundy mezi panely
}
 
/**
 * Animuje splnƒõn√≠ c√≠le - panel na m≈ô√≠≈æce zesvƒõtl√≠, zmiz√≠, objev√≠ se v c√≠li
 * @param {number} gridIndex - Pozice panelu na m≈ô√≠≈æce
 * @param {number} targetIndex - Index c√≠lov√©ho panelu (0-3)
 */
function animateTargetCompletion(gridIndex, targetIndex) {
    console.log(`üé¨ Animace splnƒõn√≠: m≈ô√≠≈æka[${gridIndex}] ‚Üí c√≠l[${targetIndex}]`);
    
    const gridCell = document.querySelector(`[data-index="${gridIndex}"]`);
    if (!gridCell) {
        console.error(`‚ùå gridCell nenalezen pro index ${gridIndex}`);
        return;
    }
    console.log(`‚úÖ gridCell nalezen:`, gridCell);
    
    const panelElement = gridCell.querySelector('.led-panel');
    if (!panelElement) {
        console.error(`‚ùå panelElement nenalezen v gridCell`);
        return;
    }
    console.log(`‚úÖ panelElement nalezen:`, panelElement);
    
    // Zak√°zat interakci s t√≠mto panelem
    panelElement.classList.add('panel-non-interactive');
    
    // F√ÅZE 1: Zesvƒõtlen√≠ (0.0s - 0.2s)
    panelElement.classList.add('panel-brightening');
    console.log(`üé® P≈ôid√°na t≈ô√≠da panel-brightening, classList:`, panelElement.classList);
    
    setTimeout(() => {
        // F√ÅZE 2: Mizen√≠ (0.2s - 0.4s)
        panelElement.classList.add('panel-fading');
        console.log(`üé® P≈ôid√°na t≈ô√≠da panel-fading, classList:`, panelElement.classList);
        
        setTimeout(() => {
            console.log(`‚è∞ Timeout 2 spu≈°tƒõn - po 0.4s celkem`);
            console.log(`  gameState.grid[${gridIndex}] p≈ôed null:`, gameState.grid[gridIndex]);
            
            // F√ÅZE 3: Zmizen√≠ z m≈ô√≠≈æky a p≈ôesun do c√≠le (0.4s)
            gameState.grid[gridIndex] = null;
            renderGrid();
            
            // Oznaƒç c√≠l jako splnƒõn√Ω
            gameState.completedTargets[targetIndex] = true;
            
            console.log(`  Vol√°m animateTargetPanelAppearance(${targetIndex})`);
            
            // Vykresli c√≠lov√Ω ≈ô√°dek s animac√≠
            animateTargetPanelAppearance(targetIndex);
            
            // Reset ƒçasom√≠ry po splnƒõn√≠ c√≠le
            resetTimer();
            
            // Zkontroluj v√≠tƒõzstv√≠ a refill A≈Ω PO dokonƒçen√≠ animace goal panelu (0.2s)
            setTimeout(() => {
                checkVictory();
                checkAndRefillGrid();
            }, 200); // Poƒçkej na dokonƒçen√≠ animace goal panelu
            
        }, 100); // Po 0.2s mizen√≠
        
    }, 100); // Po 0.2s zesvƒõtlen√≠
}

/**
 * Animuje objeven√≠ panelu v c√≠lov√©m ≈ô√°dku
 * @param {number} targetIndex - Index c√≠lov√©ho panelu (0-3)
 */
function animateTargetPanelAppearance(targetIndex) {
    console.log(`üéØ animateTargetPanelAppearance SPU≈†TƒöN pro targetIndex=${targetIndex}`);
    
    const targetRow = document.getElementById('target-row');
    console.log(`  targetRow:`, targetRow);
    
    const targetCells = targetRow.querySelectorAll('.target-panel');
    console.log(`  targetCells.length:`, targetCells.length);
    
    const targetCell = targetCells[targetIndex];
    console.log(`  targetCell[${targetIndex}]:`, targetCell);
    
    if (!targetCell) return;
    
    // Vyƒçisti bu≈àku
    targetCell.innerHTML = '';
    
    // Vytvo≈ô panel s b√≠l√Ωm filtrem
    const panelValue = gameState.targetPanels[targetIndex];
    const panelElement = createPanelElement(panelValue);
    panelElement.classList.add('target-panel-appearing');
    targetCell.appendChild(panelElement);
    
    // Po mal√©m delay odeber b√≠l√Ω filtr (trigger transition)
    setTimeout(() => {
        panelElement.classList.remove('target-panel-appearing');
        panelElement.classList.add('target-panel-normal');
    }, 10); // Mal√Ω delay pro trigger transition
}
 
 
 // ========== KONTROLA C√çL≈Æ ==========

/**
 * Zkontroluje, zda panel odpov√≠d√° nƒõjak√©mu c√≠lov√©mu panelu
 * @param {number} gridIndex - Pozice v m≈ô√≠≈æce
 */
function checkTargetMatch(gridIndex) {
    const panelValue = gameState.grid[gridIndex];
    
    if (panelValue === null) {
        return false; // ≈Ω√°dn√Ω panel na t√©to pozici
    }
    
    // Projdi v≈°echny c√≠lov√© panely
    for (let i = 0; i < gameState.targetPanels.length; i++) {
        const targetPanel = gameState.targetPanels[i];
        
        // Pokud panel odpov√≠d√° c√≠li A tento c√≠l je≈°tƒõ nen√≠ splnƒõn√Ω
        if (panelValue === targetPanel && !gameState.completedTargets[i]) {
            console.log(`‚úÖ Panel na pozici ${gridIndex} odpov√≠d√° c√≠li ${i}!`);
            
            // Spus≈• animaci m√≠sto okam≈æit√©ho zmizen√≠
            animateTargetCompletion(gridIndex, i);
            
            return true; // Na≈°li jsme shodu
        }
    }
    
    return false; // ≈Ω√°dn√° shoda
}


/**
 * Animace p≈ôechodu mezi levely
 * @param {Function} callback - Funkce kter√° se zavol√° po animaci
 */
function playLevelTransition(callback) {
    const transition = document.getElementById('level-transition');
    const addButton = document.getElementById('add-button');
    const timerContainer = document.getElementById('timer-bar-container');
    const gridElement = document.getElementById('game-grid');
    
    // Zobraz overlay
    transition.style.display = 'block';
    
    // Skryj tlaƒç√≠tko +, ƒçasom√≠ru a m≈ô√≠≈æku
    addButton.style.display = 'none';
    timerContainer.style.display = 'none';
    gridElement.style.display = 'none';
    
    // Fade in (0.3s)
    setTimeout(() => {
        transition.classList.add('fade-in');
    }, 10);
    
    // Po 0.3s fade in + 1s ƒçek√°n√≠ = 1.3s ‚Üí zaƒçni fade out
    setTimeout(() => {
        transition.classList.remove('fade-in');
        
        // Po fade out (0.3s) ‚Üí ukonƒçen√≠ celkem po 1.6s
        setTimeout(() => {
            // Skryj overlay
            transition.style.display = 'none';
            
            // Zobraz zpƒõt UI
            addButton.style.display = 'block';
            timerContainer.style.display = 'block';
            gridElement.style.display = 'grid';
            
            // Zavolej callback (naƒçten√≠ nov√©ho levelu)
            if (callback) callback();
        }, 300); // Fade out trv√° 0.3s
    }, 1300); // Fade in (0.3s) + zobrazen√≠ (1s)
}

/**
 * Zkontroluje, zda hr√°ƒç vyhr√°l (v≈°echny 4 c√≠le splnƒõny)
 */
function checkVictory() {
    const allCompleted = gameState.completedTargets.every(completed => completed === true);
    
    if (allCompleted) {
        stopTimer(); // Zastav ƒçasom√≠ru
        
        console.log("üéâ V√çTƒöZSTV√ç! Level dokonƒçen!");
        
        // Zkontroluj, zda existuje dal≈°√≠ level
        const nextLevelNumber = gameState.level + 1;
        const nextLevelExists = LEVELS.find(l => l.levelNumber === nextLevelNumber);
        
        if (nextLevelExists) {
            // Existuje dal≈°√≠ level - spus≈• p≈ôechodovou animaci
            playLevelTransition(() => {
                initLevel(nextLevelNumber);
            });
        } else {
            // Byl to posledn√≠ level
            alert(`Gratulujeme! Dokonƒçili jste v≈°echny levely! üéâ`);
            
            const restart = confirm("Chcete zaƒç√≠t znovu od levelu 1?");
            if (restart) {
                initLevel(1);
            }
        }
    }
}
 
function handlePanelClick(gridIndex) {
	// Bƒõhem dosyp√°n√≠ nelze klikat
    if (gameState.isRefilling) {
        return;
    }
    // Zkontroluj, zda na pozici je panel
    if (gameState.grid[gridIndex] === null) {
        return;
    }
    
    // Zkamenƒõl√© panely nelze flipovat
    if (isPetrified(gridIndex)) {
        console.log("üíé Zkamenƒõl√Ω panel nelze flipovat");
        return;
    }
    
    // Proveƒè NOT operaci
    const oldValue = gameState.grid[gridIndex];
    const newValue = notOperation(oldValue);
    
    console.log(`Kliknut√≠ na pozici ${gridIndex}:`);
    console.log(`  P≈Øvodn√≠: ${oldValue.toString(2).padStart(7, '0')}`);
    console.log(`  Nov√°:    ${newValue.toString(2).padStart(7, '0')}`);
    
    // Uprav stav a p≈ôekresli (panel dostane novou vizu√°ln√≠ podobu)
    gameState.grid[gridIndex] = newValue;
    renderGrid();
    
    // Zkontroluj, zda panel odpov√≠d√° nƒõkter√©mu c√≠li (najde novƒõ vykreslen√Ω element)
    checkTargetMatch(gridIndex);
    
    // Zkontroluj, zda nevznikla osmiƒçka
    checkAndPetrifyEight(gridIndex);
    
}

// ========== ZKAMENƒöL√â OSMIƒåKY ==========

/**
 * Zkontroluje, zda panel na dan√© pozici je osmiƒçka a zkamen√≠ ji, pokud nen√≠ pot≈ôeba
 * @param {number} gridIndex - Pozice v m≈ô√≠≈æce
 */
function checkAndPetrifyEight(gridIndex) {
    const panelValue = gameState.grid[gridIndex];
    
    // Zkontroluj, zda je to osmiƒçka (v≈°ech 7 segment≈Ø)
    if (panelValue === 0b1111111) {
        // Zjisti, kolik osmiƒçek je v c√≠lov√Ωch panelech
        const eightTargetIndices = [];
        gameState.targetPanels.forEach((target, index) => {
            if (target === 0b1111111) {
                eightTargetIndices.push(index);
            }
        });
        
        // Zjisti, kolik z tƒõchto osmiƒçek je NESPLNƒöN√ùCH
        const uncompletedEightCount = eightTargetIndices.filter(index => 
            !gameState.completedTargets[index]
        ).length;
        
        // Pokud nen√≠ ≈æ√°dn√° nesplnƒõn√° osmiƒçka v c√≠lech, zkame≈à tuto osmiƒçku
        if (uncompletedEightCount === 0 && !gameState.petrifiedPositions.includes(gridIndex)) {
            gameState.petrifiedPositions.push(gridIndex);
            console.log(`üíé Osmiƒçka na pozici ${gridIndex} zkamenƒõl√° (nadbyteƒçn√°)!`);
            renderGrid();
        }
    }
}

/**
 * Zkontroluje, zda je pozice zkamenƒõl√°
 * @param {number} gridIndex - Pozice v m≈ô√≠≈æce
 * @returns {boolean}
 */
function isPetrified(gridIndex) {
    return gameState.petrifiedPositions.includes(gridIndex);
}

/**
 * P≈ôipoj√≠ event listeners na v≈°echny bu≈àky m≈ô√≠≈æky
 */
/**
 * P≈ôipoj√≠ event listeners na v≈°echny bu≈àky m≈ô√≠≈æky
 */
function attachGridListeners() {
    const cells = document.querySelectorAll('.grid-cell');
    cells.forEach(cell => {
        const index = parseInt(cell.dataset.index);
        
        // Stav pro detekci kliknut√≠ vs. drag na mobilu
        let touchStartTime = 0;
        let touchMoved = false;
        let touchStartPos = { x: 0, y: 0 };
        
        // KLIKNUT√ç (NOT operace) - pouze pokud NETAH√ÅME
        cell.addEventListener('click', (e) => {
            if (!dragState.isDragging) {
                handlePanelClick(index);
            }
        });
        
        // DRAG START - mousedown
        cell.addEventListener('mousedown', (e) => {
            handleDragStart(index, e);
        });
        
        // TOUCH START - sleduj ƒças a pohyb
        cell.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            touchMoved = false;
            touchStartPos.x = e.touches[0].clientX;
            touchStartPos.y = e.touches[0].clientY;
            
            // Spus≈• drag start (pro p≈ô√≠pad ≈æe to bude drag)
            handleDragStart(index, e);
        }, { passive: false });
        
        // TOUCH MOVE - oznaƒç ≈æe se h√Ωbe
        cell.addEventListener('touchmove', (e) => {
            const deltaX = Math.abs(e.touches[0].clientX - touchStartPos.x);
            const deltaY = Math.abs(e.touches[0].clientY - touchStartPos.y);
            
            if (deltaX > 5 || deltaY > 5) {
                touchMoved = true;
            }
        }, { passive: true });
        
        // TOUCH END - rozhodni jestli to bylo kliknut√≠ nebo drag
        cell.addEventListener('touchend', (e) => {
            const touchDuration = Date.now() - touchStartTime;
            
            // Kr√°tk√Ω dotyk BEZ pohybu = kliknut√≠
            if (!touchMoved && touchDuration < 300 && !dragState.hasMovedEnough) {
                e.preventDefault();
                
                // Zru≈° drag state
                dragState.isDragging = false;
                dragState.draggedIndex = null;
                dragState.draggedValue = null;
                
                // Zavolej kliknut√≠
                handlePanelClick(index);
            }
        });
    });
}

// Glob√°ln√≠ listenery pro DRAG MOVE a DRAG END
document.addEventListener('mousemove', handleDragMove);
document.addEventListener('mouseup', handleDragEnd);
document.addEventListener('touchmove', handleDragMove, { passive: false });
document.addEventListener('touchend', handleDragEnd, { passive: false });

console.log("Drag & Drop ud√°losti napojeny");

// Uprav√≠me renderGrid() aby po ka≈æd√©m p≈ôekreslen√≠ p≈ôipojila listenery
// Najdi funkci renderGrid() a na jej√≠m KONCI (p≈ôed posledn√≠ }) p≈ôidej: 
 
// ========== DRAG & DROP (OR OPERACE) ==========

let dragState = {
    isDragging: false,
    draggedIndex: null,
    draggedValue: null,
    ghostElement: null,
    startX: 0,           // Poƒç√°teƒçn√≠ pozice X
    startY: 0,           // Poƒç√°teƒçn√≠ pozice Y
    hasMovedEnough: false // Zda u≈æ se pohnul dostateƒçnƒõ
};

/**
 * Zaƒç√°tek ta≈æen√≠ (mousedown / touchstart)
 * @param {number} gridIndex - Index pozice v m≈ô√≠≈æce
 * @param {Event} event - Event object
 */
function handleDragStart(gridIndex, event) {
	
	// Bƒõhem dosyp√°n√≠ nelze dragovat
    if (gameState.isRefilling) {
        return;
    }
	
    // Zkontroluj, zda na pozici je panel
    if (gameState.grid[gridIndex] === null) {
        return;
    }
    
    // Zkamenƒõl√© panely nelze dragovat
    if (isPetrified(gridIndex)) {
        console.log("üíé Zkamenƒõl√Ω panel nelze dragovat");
        return;
    }
    
    event.preventDefault();
    
    dragState.isDragging = true;
    dragState.draggedIndex = gridIndex;
    dragState.draggedValue = gameState.grid[gridIndex];
    dragState.hasMovedEnough = false;
    
    // Ulo≈æ poƒç√°teƒçn√≠ pozici
    dragState.startX = event.clientX || (event.touches && event.touches[0].clientX);
    dragState.startY = event.clientY || (event.touches && event.touches[0].clientY);
    
    console.log(`Zaƒç√°tek ta≈æen√≠ z pozice ${gridIndex}`);
    
    // Ghost se vytvo≈ô√≠ a≈æ p≈ôi pohybu
}

/**
 * Pohyb bƒõhem ta≈æen√≠ (mousemove / touchmove)
 * @param {Event} event - Event object
 */
function handleDragMove(event) {
    if (!dragState.isDragging) return;
    
    event.preventDefault();
    
    const x = event.clientX || (event.touches && event.touches[0].clientX);
    const y = event.clientY || (event.touches && event.touches[0].clientY);
    
    // Pokud je≈°tƒõ nen√≠ ghost vytvo≈ôen√Ω, zkontroluj, zda se pohnul dostateƒçnƒõ
    if (!dragState.hasMovedEnough) {
        const dx = x - dragState.startX;
        const dy = y - dragState.startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const DRAG_THRESHOLD = 10; // 10 pixel≈Ø minim√°ln√≠ pohyb
        
        if (distance >= DRAG_THRESHOLD) {
            dragState.hasMovedEnough = true;
            createDragGhost(event); // Teprve teƒè vytvo≈ô ghost
        }
    } else {
        // Ghost u≈æ existuje, aktualizuj jeho pozici
        updateDragGhost(event);
    }
}

/**
 * Konec ta≈æen√≠ (mouseup / touchend)
 * @param {Event} event - Event object
 */
function handleDragEnd(event) {
    if (!dragState.isDragging) return;
    
    event.preventDefault();
    
    // Najdi, na kterou bu≈àku bylo upu≈°tƒõno
    const dropIndex = getDropTarget(event);
    
    if (dropIndex !== null && dropIndex !== dragState.draggedIndex) {
        console.log(`Drop na pozici ${dropIndex}`);
        performOrOperation(dragState.draggedIndex, dropIndex);
    } else {
        console.log("Drop mimo nebo na stejnou pozici - zru≈°eno");
    }
    
// Vyƒçisti drag state
    removeDragGhost();
    dragState.isDragging = false;
    dragState.draggedIndex = null;
    dragState.draggedValue = null;
    dragState.hasMovedEnough = false;
    dragState.startX = 0;
    dragState.startY = 0;
}

console.log("Drag & Drop syst√©m p≈ôipraven");

// ========== DRAG & DROP: POMOCN√â FUNKCE ==========

/**
 * Vytvo≈ô√≠ ghost element (vizu√°ln√≠ kopie ta≈æen√©ho panelu)
 * @param {Event} event - Event object
 */
function createDragGhost(event) {
    const ghost = createPanelElement(dragState.draggedValue);
    ghost.id = 'drag-ghost';
    ghost.style.position = 'fixed';
ghost.style.width = '78px'; // 60px * 1.3 = 78px
    ghost.style.transform = 'scale(1.3)';
    ghost.style.pointerEvents = 'none';
    ghost.style.opacity = '0.7';
    ghost.style.zIndex = '1000';
    
    document.body.appendChild(ghost);
    dragState.ghostElement = ghost;
    
    updateDragGhost(event);
}

/**
 * Aktualizuje pozici ghost elementu
 * @param {Event} event - Event object
 */
function updateDragGhost(event) {
    if (!dragState.ghostElement) return;
    
    const x = event.clientX || (event.touches && event.touches[0].clientX);
    const y = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (x !== undefined && y !== undefined) {
        dragState.ghostElement.style.left = (x - 39) + 'px'; // -39 = polovina zvƒõt≈°en√© ≈°√≠≈ôky (78/2)
        dragState.ghostElement.style.top = (y - 56) + 'px';  // -56 = polovina zvƒõt≈°en√© v√Ω≈°ky (78*100/70/2)
    }
}

/**
 * Odstran√≠ ghost element
 */
function removeDragGhost() {
    if (dragState.ghostElement) {
        dragState.ghostElement.remove();
        dragState.ghostElement = null;
    }
}

/**
 * Zjist√≠, na kterou bu≈àku m≈ô√≠≈æky bylo upu≈°tƒõno
 * @param {Event} event - Event object
 * @returns {number|null} - Index bu≈àky nebo null
 */
function getDropTarget(event) {
    const x = event.clientX || (event.changedTouches && event.changedTouches[0].clientX);
    const y = event.clientY || (event.changedTouches && event.changedTouches[0].clientY);
    
    if (x === undefined || y === undefined) return null;
    
    // Najdi element na tƒõchto sou≈ôadnic√≠ch
    const element = document.elementFromPoint(x, y);
    
    // Zjisti, zda je to bu≈àka m≈ô√≠≈æky
    const cell = element?.closest('.grid-cell');
    if (cell && cell.dataset.index) {
        return parseInt(cell.dataset.index);
    }
    
    return null;
}

/**
 * Provede OR operaci mezi dvƒõma panely
 * @param {number} sourceIndex - Odkud tah√°me
 * @param {number} targetIndex - Kam dropujeme
 */
function performOrOperation(sourceIndex, targetIndex) {
	
// Nelze dropovat na zkamenƒõl√Ω panel
    if (isPetrified(targetIndex)) {
        console.log("üíé Nelze dropovat na zkamenƒõl√Ω panel");
        // Panel se vr√°t√≠ zpƒõt - nic se nestane
        renderGrid();
        return;
    }
    
    const sourceValue = gameState.grid[sourceIndex];
    const targetValue = gameState.grid[targetIndex];
    
    // Pokud je c√≠l pr√°zdn√Ω, prostƒõ p≈ôesu≈à panel
    if (targetValue === null) {
        gameState.grid[targetIndex] = sourceValue;
        gameState.grid[sourceIndex] = null;
        console.log(`Panel p≈ôesunut z ${sourceIndex} na ${targetIndex}`);
    } else {
        // Proveƒè OR operaci
        const result = orOperation(sourceValue, targetValue);
        gameState.grid[targetIndex] = result;
        gameState.grid[sourceIndex] = null;
        
        console.log(`OR operace: ${sourceIndex} + ${targetIndex}`);
        console.log(`  Panel A: ${sourceValue.toString(2).padStart(7, '0')}`);
        console.log(`  Panel B: ${targetValue.toString(2).padStart(7, '0')}`);
        console.log(`  V√Ωsledek: ${result.toString(2).padStart(7, '0')}`);
    }
    
    // P≈ôekresli m≈ô√≠≈æku (zobraz√≠ v√Ωsledek operace)
    renderGrid();
    
    // Zkontroluj, zda panel odpov√≠d√° nƒõkter√©mu c√≠li
    checkTargetMatch(targetIndex);
    
    // Zkontroluj, zda nevznikla osmiƒçka na c√≠lov√© pozici
    checkAndPetrifyEight(targetIndex);
    
    // Zkontroluj, zda nen√≠ plocha pr√°zdn√°
    checkAndRefillGrid();
}

console.log("Drag & Drop pomocn√© funkce p≈ôipraveny");

// ========== GENEROV√ÅN√ç POOL PANEL≈Æ ==========

/**
 * Rozdƒõl√≠ segmenty na N podmno≈æin (n√°hodn√© rozdƒõlen√≠)
 * @param {number} segmentMask - P≈Øvodn√≠ panel
 * @param {number} parts - Poƒçet ƒç√°st√≠ (2 nebo 3)
 * @returns {Array<number>} - Pole rozdƒõlen√Ωch panel≈Ø
 */
function splitSegments(segmentMask, parts) {
    // Zjisti, kter√© segmenty jsou rozsv√≠cen√©
    const litSegments = [];
    for (let i = 0; i < 7; i++) {
        if (segmentMask & (1 << i)) {
            litSegments.push(i);
        }
    }
    
    // Pokud je segment≈Ø m√©nƒõ ne≈æ parts, nelze rozdƒõlit
    if (litSegments.length < parts) {
        console.warn(`Nelze rozdƒõlit ${litSegments.length} segment≈Ø na ${parts} ƒç√°st√≠`);
        return [segmentMask]; // Vr√°t√≠ p≈Øvodn√≠ panel
    }
    
    // N√°hodn√© rozdƒõlen√≠ segment≈Ø do ƒç√°st√≠
    const subsets = Array(parts).fill(0).map(() => []);
    
    // Ka≈æd√° ƒç√°st mus√≠ m√≠t alespo≈à 1 segment
    for (let i = 0; i < parts; i++) {
        const randomIndex = Math.floor(Math.random() * litSegments.length);
        subsets[i].push(litSegments.splice(randomIndex, 1)[0]);
    }
    
    // Zbyl√© segmenty rozdƒõl√≠ n√°hodnƒõ
    litSegments.forEach(seg => {
        const randomPart = Math.floor(Math.random() * parts);
        subsets[randomPart].push(seg);
    });
    
    // P≈ôeveƒè zpƒõt na bin√°rn√≠ masky
    return subsets.map(subset => {
        let mask = 0;
        subset.forEach(bitIndex => {
            mask |= (1 << bitIndex);
        });
        return mask;
    });
}

// TEST rozdƒõlen√≠
// TEST rozdƒõlen√≠
console.log("=== TEST ROZDƒöLEN√ç SEGMENT≈Æ ===");
const testPanelSplit = DIGITS[8]; // 0b1111111 (v≈°echny segmenty)
console.log("P≈Øvodn√≠ panel (8):", testPanelSplit.toString(2).padStart(7, '0'));

const split2 = splitSegments(testPanelSplit, 2);

console.log("Rozdƒõleno na 2 ƒç√°sti:");
split2.forEach((part, i) => {
    console.log(`  ƒå√°st ${i+1}: ${part.toString(2).padStart(7, '0')}`);
});

const split3 = splitSegments(testPanelSplit, 3);
console.log("Rozdƒõleno na 3 ƒç√°sti:");
split3.forEach((part, i) => {
    console.log(`  ƒå√°st ${i+1}: ${part.toString(2).padStart(7, '0')}`);
});

// ========== GENEROV√ÅN√ç POOL: OPERACE A-G ==========

/**
 * Aplikuje operaci na c√≠lov√Ω panel a vr√°t√≠ pole v√Ωsledn√Ωch panel≈Ø
 * @param {number} targetPanel - C√≠lov√Ω panel (7-bit)
 * @param {string} operation - Operace ('a', 'b', 'c', 'd', 'e', 'f', 'g')
 * @returns {Array<number>} - Pole vygenerovan√Ωch panel≈Ø
 */
function applyPoolOperation(targetPanel, operation) {
    let result = [];
    
    switch(operation) {
        case 'a': // Invertovat
            result = [notOperation(targetPanel)];
            break;
            
        case 'b': // Rozdƒõlit na 2 ƒç√°sti
            result = splitSegments(targetPanel, 2);
            break;
            
        case 'c': // Rozdƒõlit na 3 ƒç√°sti
            result = splitSegments(targetPanel, 3);
            break;
            
        case 'd': // Invertovat + rozdƒõlit na 2
            const inverted_d = notOperation(targetPanel);
            result = splitSegments(inverted_d, 2);
            break;
            
        case 'e': // Invertovat + rozdƒõlit na 3
            const inverted_e = notOperation(targetPanel);
            result = splitSegments(inverted_e, 3);
            break;
            
        case 'f': // Rozdƒõlit na 2 + n√°hodnƒõ invertovat nƒõkter√© ƒç√°sti
            const parts_f = splitSegments(targetPanel, 2);
            result = parts_f.map(part => {
                return Math.random() < 0.5 ? notOperation(part) : part;
            });
            break;
            
        case 'g': // Rozdƒõlit na 3 + n√°hodnƒõ invertovat nƒõkter√© ƒç√°sti
            const parts_g = splitSegments(targetPanel, 3);
            result = parts_g.map(part => {
                return Math.random() < 0.5 ? notOperation(part) : part;
            });
            break;
            
        default:
            console.error('Nezn√°m√° operace:', operation);
            result = [targetPanel];
    }
    
    return result;
}

// TEST operac√≠
console.log("=== TEST OPERAC√ç A-G ===");
const testTarget = DIGITS[2]; // ƒå√≠slice 2
console.log("C√≠lov√Ω panel (2):", testTarget.toString(2).padStart(7, '0'));

['a', 'b', 'c', 'd', 'e'].forEach(op => {
    const panels = applyPoolOperation(testTarget, op);
    console.log(`Operace ${op}:`, panels.map(p => p.toString(2).padStart(7, '0')));
});

// ========== GENEROV√ÅN√ç POOL: OPERACE A-G ==========

/**
 * Aplikuje operaci na c√≠lov√Ω panel a vr√°t√≠ pole v√Ωsledn√Ωch panel≈Ø
 * @param {number} targetPanel - C√≠lov√Ω panel (7-bit)
 * @param {string} operation - Operace ('a', 'b', 'c', 'd', 'e', 'f', 'g')
 * @returns {Array<number>} - Pole vygenerovan√Ωch panel≈Ø
 */
function applyPoolOperation(targetPanel, operation) {
    let result = [];
    
    switch(operation) {
        case 'a': // Invertovat
            result = [notOperation(targetPanel)];
            break;
            
        case 'b': // Rozdƒõlit na 2 ƒç√°sti
            result = splitSegments(targetPanel, 2);
            break;
            
        case 'c': // Rozdƒõlit na 3 ƒç√°sti
            result = splitSegments(targetPanel, 3);
            break;
            
        case 'd': // Invertovat + rozdƒõlit na 2
            const inverted_d = notOperation(targetPanel);
            result = splitSegments(inverted_d, 2);
            break;
            
        case 'e': // Invertovat + rozdƒõlit na 3
            const inverted_e = notOperation(targetPanel);
            result = splitSegments(inverted_e, 3);
            break;
            
        case 'f': // Rozdƒõlit na 2 + n√°hodnƒõ invertovat nƒõkter√© ƒç√°sti
            const parts_f = splitSegments(targetPanel, 2);
            result = parts_f.map(part => {
                return Math.random() < 0.5 ? notOperation(part) : part;
            });
            break;
            
        case 'g': // Rozdƒõlit na 3 + n√°hodnƒõ invertovat nƒõkter√© ƒç√°sti
            const parts_g = splitSegments(targetPanel, 3);
            result = parts_g.map(part => {
                return Math.random() < 0.5 ? notOperation(part) : part;
            });
            break;
            
        default:
            console.error('Nezn√°m√° operace:', operation);
            result = [targetPanel];
    }
    
    return result;
}

// TEST operac√≠
console.log("=== TEST OPERAC√ç A-G ===");
const testOpsPanel = DIGITS[2]; // ƒå√≠slice 2
console.log("C√≠lov√Ω panel (2):", testOpsPanel.toString(2).padStart(7, '0'));

['a', 'b', 'c', 'd', 'e'].forEach(op => {
    const panels = applyPoolOperation(testOpsPanel, op);
    console.log(`Operace ${op}:`, panels.map(p => p.toString(2).padStart(7, '0')));
});

/**
 * Vygeneruje n√°hodn√Ω panel, kter√Ω nen√≠ kolizn√≠ s c√≠lov√Ωmi panely
 * N√°hodn√Ω panel m√° 1-6 segment≈Ø a nen√≠ c√≠lem ani jeho inverz√≠
 * @returns {number} - N√°hodn√Ω panel (7-bit)
 */
function generateRandomPanel() {
    const maxAttempts = 100;
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        // N√°hodn√Ω poƒçet segment≈Ø (1-6, ne 0 ani 7)
        const segmentCount = Math.floor(Math.random() * 6) + 1;
        
        // N√°hodnƒõ vyber kter√© segmenty budou sv√≠tit
        let randomPanel = 0;
        const usedSegments = new Set();
        
        while (usedSegments.size < segmentCount) {
            const segment = Math.floor(Math.random() * 7);
            usedSegments.add(segment);
        }
        
        usedSegments.forEach(seg => {
            randomPanel |= (1 << seg);
        });
        
        // Zkontroluj, zda NEN√ç kolizn√≠
        const isTarget = gameState.targetPanels.includes(randomPanel);
        const isInverted = gameState.targetPanels.includes(notOperation(randomPanel));
        
        if (!isTarget && !isInverted) {
            console.log(`‚úÖ Vygenerov√°n n√°hodn√Ω panel: ${randomPanel.toString(2).padStart(7, '0')}`);
            return randomPanel;
        }
    }
    
    // Failsafe
    console.warn(`‚ö†Ô∏è Nepoda≈ôilo se vygenerovat n√°hodn√Ω panel - pou≈æit fallback`);
    return 0b0010010;
}

// ========== GENEROV√ÅN√ç CEL√âHO POOLU ==========

/**
 * Vygeneruje pool panel≈Ø pro aktu√°ln√≠ level
 * @param {Array<string>} allowedOperations - Povolen√© operace (nap≈ô. ['b', 'c', 'd'])
 * @returns {Array<number>} - Zam√≠chan√Ω pool panel≈Ø
 */
/**
 * Vygeneruje pool panel≈Ø pro aktu√°ln√≠ level
 * @param {Array<string>} allowedOperations - Povolen√© operace (nap≈ô. ['b', 'c', 'd'])
 * @returns {Array<number>} - Zam√≠chan√Ω pool panel≈Ø
 */
function generatePool(allowedOperations) {
    let pool = [];
    
    // Pro ka≈æd√Ω ze 4 c√≠lov√Ωch panel≈Ø (ale jen nesplnƒõn√©)
    gameState.targetPanels.forEach((targetPanel, index) => {
        // P≈ôeskoƒç splnƒõn√© c√≠le
        if (gameState.completedTargets[index]) {
            console.log(`C√≠l ${index} u≈æ je splnƒõn√Ω - nep≈ôid√°v√°m do poolu`);
            return;
        }
        let panels = [];
        let attempts = 0;
        const maxAttempts = 100; // Ochrana proti nekoneƒçn√© smyƒçce
        
        // Opakuj, dokud nevzniknou panely bez p≈ô√≠m√© shody s c√≠li
        do {
            // Vyber n√°hodnou povolenou operaci
            const randomOp = allowedOperations[Math.floor(Math.random() * allowedOperations.length)];
            
            // Aplikuj operaci
            panels = applyPoolOperation(targetPanel, randomOp);
            
            attempts++;
            
            // Zkontroluj NOT kolizi - pokud operace 'a' NEN√ç povolena A jsme od levelu 5
            const notAllowed = !allowedOperations.includes('a');
            const checkNotCollision = notAllowed && gameState.level >= 5;
            
            if (checkNotCollision) {
                // Projdi v≈°echny vygenerovan√© panely
                panels = panels.map(panel => {
                    // Je tento panel NOT(c√≠lov√Ω panel)?
                    const isNotOfTarget = gameState.targetPanels.includes(notOperation(panel));
                    
                    if (isNotOfTarget) {
                        console.log(`C√≠l ${index}: panel ${panel.toString(2).padStart(7, '0')} je NOT(c√≠l) a 'a' nen√≠ povolena - nahrazen n√°hodn√Ωm`);
                        return generateRandomPanel();
                    }
                    return panel;
                });
            }
            
            // Zkontroluj, zda nƒõkter√Ω z panel≈Ø nen√≠ identick√Ω s c√≠lem
            const hasDirectMatch = panels.some(panel => 
                gameState.targetPanels.includes(panel)
            );
            
            if (!hasDirectMatch) {
                // ≈Ω√°dn√° p≈ô√≠m√° shoda - panely jsou OK
                console.log(`C√≠l ${index}: operace '${randomOp}' ‚Üí ${panels.length} panel≈Ø (pokus≈Ø: ${attempts})`);
                break;
                
            } else {
                console.log(`C√≠l ${index}: operace '${randomOp}' vytvo≈ôila v√Ωhern√≠ panel - generuji znovu...`);
            }
            
            if (attempts >= maxAttempts) {
                console.error(`C√≠l ${index}: Nepoda≈ôilo se vygenerovat validn√≠ panely po ${maxAttempts} pokusech!`);
                break;
            }
            
        } while (true);
        
        // P≈ôidej panely do poolu
        pool.push(...panels);
    });
    
    // Zam√≠chej pool (pokud je to povoleno v level datech)
    const levelData = LEVELS.find(l => l.levelNumber === gameState.level);
    const shouldShuffle = levelData?.shufflePool !== false; // Default = true (zam√≠chat)
    
    if (shouldShuffle) {
        shuffleArray(pool);
        console.log(`Pool vygenerov√°n: ${pool.length} panel≈Ø (zam√≠chan√Ω)`);
    } else {
        console.log(`Pool vygenerov√°n: ${pool.length} panel≈Ø (postupn√Ω - tutori√°l)`);
    }
    
    return pool;
}

/**
 * Zam√≠ch√° pole (Fisher-Yates shuffle)
 * @param {Array} array - Pole k zam√≠ch√°n√≠
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

/**
 * Vygeneruje nov√Ω pool podle aktu√°ln√≠ho levelu
 */
function regeneratePool() {
    // Najdi data aktu√°ln√≠ho levelu
    const levelData = LEVELS.find(l => l.levelNumber === gameState.level);
    
    if (!levelData) {
        console.error(`Level ${gameState.level} nenalezen p≈ôi generov√°n√≠ poolu!`);
        return;
    }
    
    console.log(`Generuji nov√Ω pool pro level ${gameState.level} s operacemi: ${levelData.allowedOperations.join(', ')}`);
    
    // Vygeneruj pool s operacemi z levelu
    const allowedOps = levelData.allowedOperations;
    gameState.panelPool = generatePool(allowedOps);
}


// ========== ƒåASOM√çRA ==========

/**
 * Spust√≠ ƒçasom√≠ru
 */
function startTimer() {
    // Zastav p≈ô√≠padn√Ω bƒõ≈æ√≠c√≠ timer
    stopTimer();
    
    // Nastav plnou ƒçasom√≠ru
    gameState.timerRemaining = gameState.timerDuration;
    updateTimerBar();
    
    // Spus≈• interval (aktualizace ka≈æd√Ωch 100ms)
    gameState.timerInterval = setInterval(() => {
        gameState.timerRemaining -= 100;
        
        // Aktualizuj vizu√°ln√≠ prou≈æek
        updateTimerBar();
        
        // Pokud ƒças vypr≈°el
        if (gameState.timerRemaining <= 0) {
            console.log("‚è∞ ƒåas vypr≈°el - p≈ôid√°v√°m panel");
            handleAddButton(); // Automaticky p≈ôid√° panel
            startTimer(); // Restart timeru
        }
    }, 100);
    
    console.log("ƒåasom√≠ra spu≈°tƒõna");
}

/**
 * Zastav√≠ ƒçasom√≠ru
 */
function stopTimer() {
    if (gameState.timerInterval) {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
    }
}

/**
 * Aktualizuje vizu√°ln√≠ prou≈æek ƒçasom√≠ry
 */
function updateTimerBar() {
    // Invertuj procenta - timer postupnƒõ NAR≈ÆST√Å zleva doprava
    const elapsed = gameState.timerDuration - gameState.timerRemaining;
    const percentage = (elapsed / gameState.timerDuration) * 100;
    const timerBar = document.getElementById('timer-bar');
    timerBar.style.width = percentage + '%';
}

/**
 * Reset timeru p≈ôi manu√°ln√≠m p≈ôid√°n√≠ panelu
 */
function resetTimer() {
    startTimer();
}

console.log("ƒåasom√≠ra p≈ôipravena");


    </script>
</body>
</html>
