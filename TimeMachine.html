<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stroj ƒçasu</title>
    
    <!-- Naƒçten√≠ level≈Ø -->
<script src="levels.js"></script>
    
    <style>
		
		/* Import Google Font */
@import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');

       * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    user-select: none; 
    -webkit-user-select: none;
}

body {
    font-family: Arial, sans-serif;
    background-color: #2E3949;
    overflow: hidden;
    touch-action: none;
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    
    user-select: none;
    -webkit-user-select: none;
}


/* Year display v Game Over overlay */
#year-display {
    position: absolute;
    top: 70.8%; 
    left: 50%;
    transform: translate(-50%, -50%);
   font-family: 'MedievalSharp', serif;
    font-size: 9vh; /* Velk√© p√≠smo, responsive */
    color: #E6C97D;
    text-align: center;
    pointer-events: none; /* Neklikateln√© */
    white-space: nowrap; /* Nezalamovat */
}

#game-container {
    /* Fixn√≠ aspect ratio 1:2 (≈°√≠≈ôka:v√Ω≈°ka) */
    aspect-ratio: 1 / 2;
    
    /* Vypln√≠ obrazovku, ale nep≈ôes√°hne */
    width: 100vw;
    max-width: 50vh;  /* Max ≈°√≠≈ôka = 50% viewport height */
    height: 100vh;
    max-height: 200vw; /* Max v√Ω≈°ka = 200% viewport width */
    
    /* Vnit≈ôn√≠ layout */
    padding: 2vh;
    display: flex;
    flex-direction: column;
    gap: 1vh;
    
    /* Zaji≈°tƒõn√≠ ≈æe obsah se nevypr≈°√≠ */
    box-sizing: border-box;
    position: relative;
}

#target-row {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 5px;
}

.target-panel {
    clip-path: polygon(11.43% 0%, 88.57% 0%, 100% 8%, 100% 92%, 88.57% 100%, 11.43% 100%, 0% 92%, 0% 8%);
}



#game-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 5px;
    width: 100%;
}

.grid-cell {
    aspect-ratio: 0.7; /* 70:100 */
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
}

/* Tlaƒç√≠tko + s ƒçasom√≠rou jako pozad√≠m */
#add-button {
    position: relative;
    overflow: hidden;
    width: 100%;
    aspect-ratio: 4.4 / 1;
    height: auto;
    background-color: #4B678E;
    color: white;
    font-size: 24px;
    border: none;
    cursor: pointer;
    z-index: 1;
	}

#add-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: var(--timer-width, 0%); /* CSS promƒõnn√° */
    height: 100%;
    background-color: #6B8DB8; /* Svƒõtle modr√° */
    transition: width 0.1s linear;
    z-index: -1; /* Pod textem */
}

#add-button:hover {
    filter: brightness(1.1);
}

#add-button:active {
    filter: brightness(0.9);
}

/* Animace splnƒõn√≠ c√≠le */
.panel-brightening {
    filter: brightness(3) !important;
    transition: filter 0.1s ease-out;
}

.panel-fading {
    opacity: 0 !important;
    transition: opacity 0.1s ease-out;
}

.target-panel-appearing {
    filter: brightness(3);
    transition: filter 0.1s ease-out;
}


.panel-non-interactive {
    pointer-events: none !important;
}

/* Zelen√© segmenty pro splnƒõn√© c√≠lov√© panely */
.target-panel .segment {
    filter: brightness(1) hue-rotate(40deg) saturate(3) !important;
}

/* P≈ôechodov√° animace mezi levely */
#level-transition {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90vw;
    max-width: 45vh;
    aspect-ratio: 1 / 1.5;
    background-color: #242D3A;
    opacity: 0;
    z-index: 2000;
    pointer-events: none;
    transition: opacity 0.3s ease-in-out;
}

#level-transition.fade-in {
    opacity: 1;
}

#windmill {
    width: 100%;
    height: 100%;
    object-fit: contain;
    opacity: 0;
}

/* Animace rotace vƒõtrn√≠ku */
@keyframes rotate-windmill {
    from { transform: rotate(90deg); }
    to { transform: rotate(0deg); }
}

/* Kdy≈æ je transition aktivn√≠, rotuj vƒõtrn√≠k */
#level-transition.fade-in #windmill {
    opacity: 1;
    animation: rotate-windmill 1s linear;
    animation-delay: 0s; /* Zaƒçne hned po fade-in */
}

/* ƒå√≠slo verze */
#version {
    position: absolute;
    bottom: 1vh;
    right: 2vh;
    font-size: 0.8em;
    color: #666;
    opacity: 0.7;
}

/* Pause overlay */
#pause-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    max-width: 50vh;
    aspect-ratio: 1 / 2;
    background-color: #2E3949;
    background-image: url('assets/pause.svg'); /* P≈òIDEJ */
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 3000;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Intro overlay */
#intro-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    max-width: 50vh;
    aspect-ratio: 1 / 2;
    background-color: #2E3949;
    background-image: url('assets/homescreen.svg'); /* P≈òIDEJ */
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 4000;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Game Over overlay */
#gameover-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    max-width: 50vh;
    aspect-ratio: 1 / 2;
    background-color: #2E3949;
    background-image: url('assets/game_over.svg'); 
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 4000;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Victory overlay */
#victory-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    max-width: 50vh;
    aspect-ratio: 1 / 2;
    background-color: #2E3949;
    background-image: url('assets/you_win.svg'); /* P≈òIDEJ */
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 4000;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Help overlay */
#help-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    max-width: 50vh;
    aspect-ratio: 1 / 2;
    background-color: #2E3949; /* Tmavƒõ modro≈°ed√° */
    background-image: url('assets/help_credits.svg');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 5000; /* Vy≈°≈°√≠ ne≈æ ostatn√≠ overlaye */
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* New Game confirmation overlay */
#newgame-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    max-width: 50vh;
    aspect-ratio: 1 / 2;
    background-color: #2E3949; /* Stejn√° jako help */
    background-image: url('assets/newgame_yes_no.svg');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 5000; /* Stejn√° jako help */
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Load overlay */
#load-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    max-width: 50vh;
    aspect-ratio: 1 / 2;
    background-color: #2E3949;
    background-image: url('assets/homescreen_continue.svg'); /* P≈òIDEJ */
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 4000;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Tutorial overlays */
.tutorial-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    max-width: 50vh;
    aspect-ratio: 1 / 2;
    background-color: transparent; /* Pr≈Øhledn√© pozad√≠ */
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 1500; 
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: all; /* Blokuje kliky pod sebou */
}

#tut01-merge {
    background-image: url('assets/tut01_merge.svg');
}

#tut02-invert {
    background-image: url('assets/tut02_invert.svg');
}

#tut03-add {
    background-image: url('assets/tut03_add.svg');
}

#tut04-shape8 {
    background-image: url('assets/tut04_shape8.svg');
}

    </style>
</head>
<body>
    <div id="game-container">
        <!-- C√≠lov√Ω ≈ô√°dek -->
<div id="target-row">
    <div class="target-panel" id="target-0"></div>
    <div class="target-panel" id="target-1"></div>
    <div class="target-panel" id="target-2"></div>
    <div class="target-panel" id="target-3"></div>
</div>


<!-- Hern√≠ pole 5x5 -->
<div id="game-grid"></div>

<!-- Tlaƒç√≠tko + -->
<div style="display: flex; gap: 5px; width: 100%;">
    <button id="pause-button" style="flex: 2; font-size: 1.5em; background-color: #444; cursor: pointer; border: none; color: white; aspect-ratio: 2.9/1; display: flex; align-items: center; justify-content: center;">II</button>
    <button id="add-button" style="flex: 3;">+</button>
</div>
<div id="version">v1.40</div>
    </div>
    
<!-- P≈ôechodov√° animace mezi levely -->
<div id="level-transition" style="display: none;">
    <img src="assets/vetrnik_travel.svg" id="windmill" alt="">
</div>

<!-- Pause overlay -->
<div id="pause-overlay" style="display: none;"></div>

<!-- Intro overlay -->
<div id="intro-overlay" style="display: none;"></div>

<!-- Game Over overlay -->
<div id="gameover-overlay" style="display: none;">
    <div id="year-display"></div>
</div>

<!-- Victory overlay -->
<div id="victory-overlay" style="display: none;"></div>

<!-- Help overlay -->
<div id="help-overlay" style="display: none;"></div>

<!-- New Game confirmation overlay -->
<div id="newgame-overlay" style="display: none;"></div>

<!-- Load overlay -->
<div id="load-overlay" style="display: none;"></div>

<!-- Tutorial overlays -->
<div id="tut01-merge" class="tutorial-overlay" style="display: none;"></div>
<div id="tut02-invert" class="tutorial-overlay" style="display: none;"></div>
<div id="tut03-add" class="tutorial-overlay" style="display: none;"></div>
<div id="tut04-shape8" class="tutorial-overlay" style="display: none;"></div>
    
    <script>
        // ========== KONSTANTY A KONFIGURACE ==========
const GRID_SIZE = 5; // Velikost m≈ô√≠≈æky (5x5)
const PANEL_RATIO = 70 / 100; // Pomƒõr stran panelu

// ========== HELP OVERLAY TRACKING ==========
let previousOverlay = null;

// Standardn√≠ sedmisegmentov√Ω displej - mapov√°n√≠ segment≈Ø na bity
// Pozice: gfedcba (bit 6 a≈æ 0)
const SEGMENTS = {
    a: 0b0000001,
    b: 0b0000010,
    c: 0b0000100,
    d: 0b0001000,
    e: 0b0010000,
    f: 0b0100000,
    g: 0b1000000
};


// ========== UKL√ÅD√ÅN√ç HRY ==========

/**
 * Ulo≈æ√≠ aktu√°ln√≠ stav hry do localStorage
 * @param {number} levelToSave - ƒå√≠slo levelu k ulo≈æen√≠ (voliteln√©, default = gameState.level)
 */
function saveGame(levelToSave = null) {
    const saveData = {
        level: levelToSave || gameState.level,
        petrifiedPositions: gameState.petrifiedPositions
    };
    
    try {
        localStorage.setItem('timemachine_save', JSON.stringify(saveData));
        console.log(`üíæ Hra ulo≈æena: Level ${saveData.level}, Petrified: ${saveData.petrifiedPositions}`);
    } catch (e) {
        console.error('‚ùå Chyba p≈ôi ukl√°d√°n√≠:', e);
    }
}

/**
 * Naƒçte ulo≈æen√Ω stav hry z localStorage
 * @returns {Object|null} - Ulo≈æen√° data nebo null
 */
function loadGame() {
    try {
        const saveString = localStorage.getItem('timemachine_save');
        if (!saveString) {
            console.log('üìÇ ≈Ω√°dn√Ω ulo≈æen√Ω stav');
            return null;
        }
        
        const saveData = JSON.parse(saveString);
        console.log(`üìÇ Hra naƒçtena: Level ${saveData.level}, Petrified: ${saveData.petrifiedPositions}`);
        return saveData;
    } catch (e) {
        console.error('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠:', e);
        return null;
    }
}

/**
 * Sma≈æe ulo≈æen√Ω stav hry
 */
function clearSave() {
    try {
        localStorage.removeItem('timemachine_save');
        console.log('üóëÔ∏è Ulo≈æen√Ω stav smaz√°n');
    } catch (e) {
        console.error('‚ùå Chyba p≈ôi maz√°n√≠:', e);
    }
}

// ========== TUTORI√ÅL TRACKING ==========

/**
 * Naƒçte stav vidƒõn√Ωch tutori√°l≈Ø z localStorage
 * @returns {Object} - Objekt s id tutori√°l≈Ø a boolean hodnotami
 */
function loadTutorialProgress() {
    try {
        const tutString = localStorage.getItem('timemachine_tutorials');
        if (!tutString) {
            // ≈Ω√°dn√Ω z√°znam - ≈æ√°dn√Ω tutori√°l nebyl vidƒõn
            return {
                tut01: false,
                tut02: false,
                tut03: false,
                tut04: false
            };
        }
        return JSON.parse(tutString);
    } catch (e) {
        console.error('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ tutori√°l≈Ø:', e);
        return {
            tut01: false,
            tut02: false,
            tut03: false,
            tut04: false
        };
    }
}

/**
 * Zkontroluje, zda byl tutori√°l ji≈æ vidƒõn
 * @param {string} tutId - ID tutori√°lu (nap≈ô. 'tut01')
 * @returns {boolean} - True pokud byl vidƒõn
 */
function isTutorialSeen(tutId) {
    const progress = loadTutorialProgress();
    return progress[tutId] === true;
}

/**
 * Oznaƒç√≠ tutori√°l jako vidƒõn√Ω
 * @param {string} tutId - ID tutori√°lu (nap≈ô. 'tut01')
 */
function markTutorialSeen(tutId) {
    try {
        const progress = loadTutorialProgress();
        progress[tutId] = true;
        localStorage.setItem('timemachine_tutorials', JSON.stringify(progress));
        console.log(`üìö Tutori√°l ${tutId} oznaƒçen jako vidƒõn√Ω`);
    } catch (e) {
        console.error('‚ùå Chyba p≈ôi ukl√°d√°n√≠ tutori√°lu:', e);
    }
}

// ========== HERN√ç STAV ==========
let gameState = {
    level: 1,
    grid: Array(GRID_SIZE * GRID_SIZE).fill(null),
    targetPanels: [],
    completedTargets: [false, false, false, false],
    panelPool: [],
    timerInterval: null,
    timerDuration: 5000,
    timerRemaining: 5000,
    isIntroSequence: false,
    petrifiedPositions: [],
    isRefilling: false,
    introInterval: null,      // Reference na intro interval
    refillInterval: null      // Reference na refill interval
};

// ========== INICIALIZACE ==========
console.log("Stroj ƒçasu - hern√≠ engine inicializov√°n");
console.log("Velikost m≈ô√≠≈æky:", GRID_SIZE, "x", GRID_SIZE);
console.log("C√≠lov√© panely pro level 1 (2025):", [
    DIGITS[2], DIGITS[0], DIGITS[2], DIGITS[5]
]);
// ========== VYKRESLOV√ÅN√ç PANEL≈Æ ==========

/**
 * Vytvo≈ô√≠ HTML element panelu s LED displejem
 * @param {number} segmentMask - 7-bitov√© ƒç√≠slo reprezentuj√≠c√≠ rozsv√≠cen√© segmenty
 * @returns {HTMLElement} -Div element s panelem
 */
function createPanelElement(segmentMask) {
    const panel = document.createElement('div');
    panel.className = 'led-panel';
    panel.style.position = 'relative';
    panel.style.width = '100%';
    panel.style.aspectRatio = PANEL_RATIO;
    
    // Pozad√≠ panelu
    const bg = document.createElement('img');
    bg.src = 'assets/panel_bg.svg';
    bg.style.position = 'absolute';
    bg.style.width = '100%';
    bg.style.height = '100%';
    bg.style.top = '0';
    bg.style.left = '0';
    panel.appendChild(bg);
    
    // P≈ôid√°n√≠ segment≈Ø podle masky
    const segmentNames = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
    segmentNames.forEach((name, index) => {
        const bitMask = 1 << index; // 2^index
        if (segmentMask & bitMask) { // Pokud je segment rozsv√≠cen√Ω
            const seg = document.createElement('img');
            seg.src = `assets/seg_${name}.svg`;
            seg.className = `segment seg-${name}`;
            seg.style.position = 'absolute';
            seg.style.width = '100%';
            seg.style.height = '100%';
            seg.style.top = '0';
            seg.style.left = '0';
            seg.style.pointerEvents = 'none';
            panel.appendChild(seg);
        }
    });
    
    // Ulo≈æen√≠ hodnoty segment≈Ø jako data atribut
    panel.dataset.segments = segmentMask;
    
    return panel;
}

// TEST: Vytvo≈ôen√≠ testovac√≠ho panelu s ƒç√≠slic√≠ "8" (v≈°echny segmenty)
console.log("Test: Vytv√°≈ôen√≠ panelu s ƒç√≠slic√≠ 8");
const testPanel = createPanelElement(DIGITS[8]);
console.log("Panel vytvo≈ôen:", testPanel);
// ========== VYKRESLOV√ÅN√ç M≈ò√ç≈ΩKY ==========

/**
 * Synchronizuje stav gridu s DOM (bez niƒçen√≠ struktury)
 */
function renderGrid() {
    // Projdi v≈°echny pozice a synchronizuj
    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        if (gameState.grid[i] !== null) {
            addPanelToCell(i, gameState.grid[i]);
        } else {
            removePanelFromCell(i);
        }
    }
}

/**
 * Inicializuje statick√Ω DOM grid - vol√° se pouze p≈ôi vytvo≈ôen√≠/resetu gridu
 */
function initGrid() {
    const gridElement = document.getElementById('game-grid');
    gridElement.innerHTML = ''; // Vyƒçist√≠ grid (jen p≈ôi inicializaci)
    
    // Vytvo≈ôen√≠ 25 bunƒõk
    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.dataset.index = i;
        cell.style.backgroundColor = '#1a1a1a';
        cell.style.clipPath = 'polygon(11.43% 0%, 88.57% 0%, 100% 8%, 100% 92%, 88.57% 100%, 11.43% 100%, 0% 92%, 0% 8%)';
        cell.style.display = 'flex';
        cell.style.alignItems = 'center';
        cell.style.justifyContent = 'center';
        cell.style.position = 'relative';
        
        gridElement.appendChild(cell);
    }
    
    attachGridListeners();
}

/**
 * P≈ôid√° panel do konkr√©tn√≠ bu≈àky gridu
 * @param {number} index - Index bu≈àky (0-24)
 * @param {number} segmentMask - Hodnota panelu (7-bit)
 */
function addPanelToCell(index, segmentMask) {
    const cell = document.querySelector(`.grid-cell[data-index="${index}"]`);
    if (!cell) return;
    
    // Vyƒçist√≠ bu≈àku
    cell.innerHTML = '';
    
    // Vytvo≈ô panel
    const panel = createPanelElement(segmentMask);
    panel.style.width = '96%';
    panel.style.height = '96%';
    
    // Pokud je panel zkamenƒõl√Ω, aplikuj efekt
    if (isPetrified(index)) {
        panel.style.filter = 'grayscale(100%) sepia(100%) hue-rotate(-50deg) saturate(300%)';
        panel.style.opacity = '0.7';
        panel.classList.add('petrified');
    }
    
    cell.appendChild(panel);
}

/**
 * Odstran√≠ panel z konkr√©tn√≠ bu≈àky gridu
 * @param {number} index - Index bu≈àky (0-24)
 */
function removePanelFromCell(index) {
    const cell = document.querySelector(`.grid-cell[data-index="${index}"]`);
    if (!cell) return;
    
    cell.innerHTML = '';
}

/**
 * P≈ôid√° panel na n√°hodnou volnou pozici v m≈ô√≠≈æce
 * @param {number} segmentMask - Hodnota panelu (7-bit)
 * @returns {boolean} - True pokud se poda≈ôilo p≈ôidat, false pokud je pole pln√©
 */
function addPanelToGrid(segmentMask) {
    // Najdi v≈°echny voln√© pozice
    const emptyPositions = [];
    for (let i = 0; i < gameState.grid.length; i++) {
        if (gameState.grid[i] === null) {
            emptyPositions.push(i);
        }
    }
    
// Pokud nen√≠ ≈æ√°dn√° voln√° pozice, hra konƒç√≠
if (emptyPositions.length === 0) {
    console.log("GAME OVER - pole je pln√©!");
    showGameOverOverlay();
    return false;
}
    
    // Vyber n√°hodnou pozici
    const randomIndex = Math.floor(Math.random() * emptyPositions.length);
    const position = emptyPositions[randomIndex];
    
// P≈ôidej panel na tuto pozici
gameState.grid[position] = segmentMask;
addPanelToCell(position, segmentMask);

console.log(`Panel p≈ôid√°n na pozici ${position}, hodnota: ${segmentMask.toString(2)}`);
return true;
}

// Inicializace statick√©ho gridu
initGrid();
console.log("M≈ô√≠≈æka 5x5 inicializov√°na");

// ========== VYKRESLOV√ÅN√ç C√çLOV√âHO ≈ò√ÅDKU ==========

/**
 * Vykresl√≠ c√≠lov√Ω ≈ô√°dek s panely
 */
function renderTargetRow() {
    for (let i = 0; i < 4; i++) {
        const targetElement = document.getElementById(`target-${i}`);
        targetElement.innerHTML = '';
        targetElement.style.width = '60px';
        targetElement.style.aspectRatio = PANEL_RATIO;
        targetElement.style.backgroundColor = '#1a1a1a';
        //targetElement.style.borderRadius = '8px';
        targetElement.style.display = 'flex';
        targetElement.style.alignItems = 'center';
        targetElement.style.justifyContent = 'center';
        targetElement.style.position = 'relative';
        
        // V≈ΩDY zobraz n√°hled c√≠lov√©ho panelu (≈°ed√Ω)
        const previewPanel = createPanelElement(gameState.targetPanels[i]);
        previewPanel.style.width = '95%';
        previewPanel.style.height = '96%';
        previewPanel.style.opacity = '0.3'; // ≈†ed√Ω n√°hled
        previewPanel.style.filter = 'grayscale(100%)'; // ƒåernob√≠l√Ω
        targetElement.appendChild(previewPanel);
        
        // Pokud je tento c√≠l splnƒõn, zobraz barevn√Ω panel P≈òES n√°hled
        if (gameState.completedTargets[i]) {
            const completedPanel = createPanelElement(gameState.targetPanels[i]);
            completedPanel.style.width = '90%';
            completedPanel.style.height = '90%';
            completedPanel.style.position = 'absolute';
            completedPanel.style.top = '50%';
            completedPanel.style.left = '50%';
            completedPanel.style.transform = 'translate(-50%, -50%)';
            targetElement.appendChild(completedPanel);
        }
    }
}

/**
 * √övodn√≠ sekvence - rychl√© p≈ôid√°n√≠ 4 panel≈Ø
 */
function playIntroSequence() {
    gameState.isIntroSequence = true;
    
    // Levely maj√≠ r≈Øzn√Ω poƒçet √∫vodn√≠ch panel≈Ø
    let panelCount;
    if (gameState.level === 1) {
        panelCount = 2;
    } else if (gameState.level === 2) {
        panelCount = 1;
    } else if (gameState.level === 3) {
        panelCount = 1;
    } else if (gameState.level === 4) {
        panelCount = 2;
    } else if (gameState.level === 5) {
        panelCount = 2;
    } else {
        panelCount = 4;
    }
    
    // Zak√°zat tlaƒç√≠tko +
    const addButton = document.getElementById('add-button');
    addButton.disabled = true;
    addButton.style.opacity = '0.5';
    addButton.style.cursor = 'not-allowed';
    
    console.log(`√övodn√≠ sekvence - p≈ôid√°v√°m ${panelCount} panely...`);
    
    let count = 0;
    gameState.introInterval = setInterval(() => {
        if (count < panelCount) {
            // P≈ôidej panel z poolu
            if (gameState.panelPool.length > 0) {
                const panelValue = gameState.panelPool.shift();
                addPanelToGrid(panelValue);
                console.log(`√övodn√≠ panel ${count + 1}/${panelCount} p≈ôid√°n`);
                count++;
            }
        } else {
            // Konec √∫vodn√≠ sekvence
            // Konec √∫vodn√≠ sekvence
            clearInterval(gameState.introInterval);
            gameState.introInterval = null;
            gameState.isIntroSequence = false;
            
            // Povolit tlaƒç√≠tko +
            addButton.disabled = false;
            addButton.style.opacity = '1';
            addButton.style.cursor = 'pointer';
            
            console.log("√övodn√≠ sekvence dokonƒçena - spou≈°t√≠m ƒçasom√≠ru");
            
            // Odstra≈à POUZE zkamenƒõl√© osmiƒçky, kter√© byly pou≈æity ke splnƒõn√≠ c√≠l≈Ø
            // (tzn. osmiƒçka je v c√≠lech A byla oznaƒçena jako splnƒõn√° v fulfillPetrifiedEights)
            if (gameState.targetPanels.includes(0b1111111)) {
                // Spoƒç√≠tej, kolik osmiƒçek bylo oznaƒçeno jako splnƒõn√©
                const completedEightsCount = gameState.targetPanels.filter((panel, index) => 
                    panel === 0b1111111 && gameState.completedTargets[index]
                ).length;
                
                // Odstra≈à tolik zkamenƒõl√Ωch osmiƒçek, kolik jich bylo splnƒõno
                const petrifiedEights = gameState.petrifiedPositions.filter(pos => 
                    gameState.grid[pos] === 0b1111111
                );
                
                for (let i = 0; i < completedEightsCount && i < petrifiedEights.length; i++) {
                    const pos = petrifiedEights[i];
                    gameState.grid[pos] = null;
                    gameState.petrifiedPositions = gameState.petrifiedPositions.filter(p => p !== pos);
                    console.log(`üíé Zkamenƒõl√° osmiƒçka na pozici ${pos} zmizela (splnƒõn c√≠l)`);
                }
                
                if (completedEightsCount > 0) {
                    renderTargetRow();
                    renderGrid();
                }
            }
            
            
            // Teƒè spus≈• ƒçasom√≠ru
            startTimer();
            
            // Zobraz tutori√°l pokud nebyl vidƒõn (500ms po naƒçten√≠)
	setTimeout(() => {
    if (gameState.level === 1) {
        showTutorial('tut01');
    } else if (gameState.level === 2) {
        showTutorial('tut02');
    } else if (gameState.level === 3) {
        showTutorial('tut03');
    }
}, 500);

        }
    }, 100); // Ka≈æd√Ωch 0.1 sekundy
}

/**
 * Spln√≠ zkamenƒõl√© osmiƒçky, pokud jsou v c√≠lech aktu√°ln√≠ho levelu
 * (Vol√° se P≈òED generov√°n√≠m poolu)
 */
function fulfillPetrifiedEights() {
    if (!gameState.targetPanels.includes(0b1111111)) {
        return; // V c√≠lech nen√≠ osmiƒçka
    }
    
    const petrifiedEightPositions = [...gameState.petrifiedPositions];
    
    petrifiedEightPositions.forEach(pos => {
        // Najdi prvn√≠ nesplnƒõn√Ω c√≠l s osmiƒçkou
        const targetIndex = gameState.targetPanels.findIndex((panel, index) => 
            panel === 0b1111111 && !gameState.completedTargets[index]
        );
        
        if (targetIndex !== -1) {
            // Oznaƒç jako splnƒõn√Ω (ale panel zat√≠m NEZMIZEL - zmiz√≠ a≈æ v √∫vodn√≠ sekvenci)
            gameState.completedTargets[targetIndex] = true;
            console.log(`üíé Zkamenƒõl√° osmiƒçka na pozici ${pos} p≈ôipravena ke splnƒõn√≠ c√≠le ${targetIndex}`);
        }
    });
}

/**
 * Inicializace levelu - nastav√≠ c√≠lov√© panely
 * @param {number} levelNumber - ƒå√≠slo levelu (1, 2, 3...)
 */
function initLevel(levelNumber) {
	
	// Zastav v≈°echny bƒõ≈æ√≠c√≠ intervaly (prevence duplicit p≈ôi p≈ôechodu level≈Ø)
    stopTimer();
    
    // Zastav intro interval, pokud bƒõ≈æ√≠
    if (gameState.introInterval) {
        clearInterval(gameState.introInterval);
        gameState.introInterval = null;
    }
    
    // Zastav refill interval, pokud bƒõ≈æ√≠
    if (gameState.refillInterval) {
        clearInterval(gameState.refillInterval);
        gameState.refillInterval = null;
    }
    
    gameState.isIntroSequence = false;
    gameState.isRefilling = false;
	
    // Najdi level v poli LEVELS
    const levelData = LEVELS.find(l => l.levelNumber === levelNumber);
    
    if (!levelData) {
        console.error(`Level ${levelNumber} nenalezen!`);
        return;
    }
    
    // Nastav hern√≠ stav podle dat levelu
    gameState.level = levelNumber;
    gameState.targetPanels = levelData.targetPanels;
    gameState.completedTargets = [false, false, false, false];
    gameState.timerDuration = levelData.timerDuration;
    gameState.timerRemaining = levelData.timerDuration;
   
// Resetuj vizu√°l ƒçasom√≠ry
document.getElementById('add-button').style.setProperty('--timer-width', '0%');
    
    // Vyƒçisti m≈ô√≠≈æku, ale zachovej zkamenƒõl√© osmiƒçky
    const oldGrid = [...gameState.grid];
    gameState.grid = Array(GRID_SIZE * GRID_SIZE).fill(null);
    
    // P≈ôenes zkamenƒõl√© osmiƒçky do nov√© m≈ô√≠≈æky
    gameState.petrifiedPositions.forEach(pos => {
        gameState.grid[pos] = oldGrid[pos];
    });    
    console.log(`Level ${levelNumber} inicializov√°n: ${levelData.displayName}`);
    console.log(`ƒåasom√≠ra: ${levelData.timerDuration}ms`);
    console.log(`Povolen√© operace: ${levelData.allowedOperations.join(', ')}`);
    
    // NEJD≈ò√çV spl≈à zkamenƒõl√© osmiƒçky (pokud jsou v c√≠lech)
    fulfillPetrifiedEights();
    
    // PAK vygeneruj pool (u≈æ v√≠, kter√© c√≠le jsou splnƒõn√©)
    const allowedOps = levelData.allowedOperations;
    gameState.panelPool = generatePool(allowedOps);
    
    // Vykresli v≈°e
    renderGrid();
    renderTargetRow();
    
    
// Skryj/zobraz tlaƒç√≠tko + podle levelu a tutori√°l≈Ø
const addButton = document.getElementById('add-button');
if (gameState.level === 1) {
    // Level 1: zobraz jen pokud byl vidƒõn tut01
    addButton.style.visibility = isTutorialSeen('tut01') ? 'visible' : 'hidden';
} else if (gameState.level === 2) {
    // Level 2: zobraz jen pokud byl vidƒõn tut02
    addButton.style.visibility = isTutorialSeen('tut02') ? 'visible' : 'hidden';
} else {
    // Level 3+: v≈ædy viditeln√©
    addButton.style.visibility = 'visible';
}
    
    // Spu≈°tƒõn√≠ √∫vodn√≠ sekvence (ƒçasom√≠ra se spust√≠ a≈æ po n√≠)
    playIntroSequence();
}

// ========== INICIALIZACE HRY P≈òI STARTU ==========

let loadUnlockTime = 0;
let loadedLevel = 1; // Level kter√Ω se m√° naƒç√≠st po odkliknut√≠

// Vykreslit pr√°zdnou m≈ô√≠≈æku (pro proporce overlay≈Ø)
renderGrid();

// Zkusit naƒç√≠st ulo≈æen√Ω stav
const savedGame = loadGame();

if (savedGame) {
    // Existuje ulo≈æen√° hra
    gameState.petrifiedPositions = savedGame.petrifiedPositions;
    
    // Napl≈à grid osmiƒçkami na zkamenƒõl√Ωch pozic√≠ch
gameState.petrifiedPositions.forEach(pos => {
    gameState.grid[pos] = 0b1111111; // Osmiƒçka
});
    
    loadedLevel = savedGame.level;
    
    // Zobraz load overlay
    const loadOverlay = document.getElementById('load-overlay');
    loadOverlay.style.display = 'flex';
    loadUnlockTime = Date.now() + 300;
    
    console.log(`üìÇ Nalezen ulo≈æen√Ω stav - level ${savedGame.level}`);
} else {
    // ≈Ω√°dn√° ulo≈æen√° hra - zobraz intro overlay
    const introOverlay = document.getElementById('intro-overlay');
    introOverlay.style.display = 'flex';
    console.log("üéÆ Nov√° hra - zobrazuji intro overlay");
}

// ========== OVL√ÅD√ÅN√ç TLAƒå√çTKA + ==========

/**
 * Obsluha kliknut√≠ na tlaƒç√≠tko +
 */
/**
 * Obsluha kliknut√≠ na tlaƒç√≠tko +
 */
function handleAddButton() {
	
	// Bƒõhem √∫vodn√≠ sekvence nelze p≈ôid√°vat panely
    if (gameState.isIntroSequence) {
        return;
    }
    
    // Pokud je pool pr√°zdn√Ω, vygeneruj nov√Ω
    if (gameState.panelPool.length === 0) {
        console.log("Pool pr√°zdn√Ω, generuji nov√Ω...");
        regeneratePool();
    }
    
    // Vezmi prvn√≠ panel z poolu
    const panelValue = gameState.panelPool.shift(); // Odebere prvn√≠ prvek
    
    console.log(`P≈ôid√°v√°m panel z poolu: ${panelValue.toString(2).padStart(7, '0')}`);
    console.log(`Zb√Ωv√° v poolu: ${gameState.panelPool.length} panel≈Ø`);
    
    // P≈ôidej panel na m≈ô√≠≈æku
    const success = addPanelToGrid(panelValue);
    
    if (!success) {
    // Game over u≈æ byl zobrazen√Ω v addPanelToGrid()
    return;
}
    // Reset timeru p≈ôi manu√°ln√≠m p≈ôid√°n√≠
    resetTimer();
}

// Napojen√≠ tlaƒç√≠tka
document.getElementById('add-button').addEventListener('click', handleAddButton);

console.log("Tlaƒç√≠tko + napojeno");
console.log("=== HRA P≈òIPRAVENA K TESTOV√ÅN√ç ===");
console.log("Klikni na tlaƒç√≠tko + pro p≈ôid√°n√≠ testovac√≠ho panelu");

// ========== LOGICK√â OPERACE ==========

/**
 * NOT operace - invertuje v≈°echny segmenty panelu
 * @param {number} segmentMask - P≈Øvodn√≠ hodnota panelu
 * @returns {number} - Invertovan√° hodnota
 */
function notOperation(segmentMask) {
    // XOR s 0b1111111 (v≈°ech 7 bit≈Ø) = inverze
    return segmentMask ^ 0b1111111;
}

/**
 * OR operace - spoj√≠ dva panely (sjednocen√≠ rozsv√≠cen√Ωch segment≈Ø)
 * @param {number} mask1 - Prvn√≠ panel
 * @param {number} mask2 - Druh√Ω panel
 * @returns {number} - Spojen√Ω panel
 */
function orOperation(mask1, mask2) {
    return mask1 | mask2;
}

// TESTY logick√Ωch operac√≠
console.log("=== TEST LOGICK√ùCH OPERAC√ç ===");
console.log("NOT operace:");
console.log("  Vstup:  0b0000110 (bc) =", 0b0000110);
console.log("  V√Ωstup:", notOperation(0b0000110).toString(2).padStart(7, '0'));

console.log("OR operace:");
console.log("  Panel A: 0b0010101 (ace) =", 0b0010101);
console.log("  Panel B: 0b1000010 (bg) =", 0b1000010);
console.log("  V√Ωsledek:", orOperation(0b0010101, 0b1000010).toString(2).padStart(7, '0'), "(abceg)");
// ========== INTERAKCE: KLIKNUT√ç NA PANEL ==========

/**
 * Obsluha kliknut√≠ na panel - provede NOT operaci
 * @param {number} gridIndex - Index pozice v m≈ô√≠≈æce (0-24)
 */
 
 
 /**
 * Zkontroluje, zda je cel√° plocha pr√°zdn√° a p≈ô√≠padnƒõ dosype 4 panely
 */
function checkAndRefillGrid() {
    // Bƒõhem √∫vodn√≠ sekvence nebo dosyp√°n√≠ nekontroluj
    if (gameState.isIntroSequence || gameState.isRefilling) {
        return;
    }
    
    // Zkontroluj, zda jsou v≈°echny pozice pr√°zdn√© (kromƒõ zkamenƒõl√Ωch)
    const allEmpty = gameState.grid.every((value, index) => {
        return value === null || gameState.petrifiedPositions.includes(index);
    });
    
    if (allEmpty) {
        console.log("üîÑ Plocha pr√°zdn√° - dosyp√°v√°m 4 panely!");
        refillGrid();
    }
}

/**
 * Automaticky dosype 4 panely p≈ôi pr√°zdn√© plo≈°e
 */
function refillGrid() {
    gameState.isRefilling = true;
    
    // Levely maj√≠ r≈Øzn√Ω poƒçet dosyp√°van√Ωch panel≈Ø
    let panelCount;
    if (gameState.level === 1) {
        panelCount = 2;
    } else if (gameState.level === 2) {
        panelCount = 1;
    } else if (gameState.level === 3) {
        panelCount = 2;
    } else if (gameState.level === 4) {
        panelCount = 2;
    } else if (gameState.level === 5) {
        panelCount = 2;
    } else {
        panelCount = 4;
    }
    
    // Zastav ƒçasom√≠ru
    stopTimer();
    
    // Zak√°zat tlaƒç√≠tko +
    const addButton = document.getElementById('add-button');
    addButton.disabled = true;
    addButton.style.opacity = '0.5';
    addButton.style.cursor = 'not-allowed';
    
    console.log(`Dosyp√°v√°m ${panelCount} panely...`);
    
    let count = 0;
    gameState.refillInterval = setInterval(() => {
        if (count < panelCount) {
            // Pokud je pool pr√°zdn√Ω, vygeneruj nov√Ω
            if (gameState.panelPool.length === 0) {
                console.log("Pool pr√°zdn√Ω bƒõhem dosyp√°n√≠ - generuji nov√Ω...");
                regeneratePool();
            }
            
            // P≈ôidej panel z poolu
            if (gameState.panelPool.length > 0) {
                const panelValue = gameState.panelPool.shift();
                addPanelToGrid(panelValue);
                console.log(`Dosyp√°n√≠: panel ${count + 1}/${panelCount} p≈ôid√°n`);
                count++;
            }
        } else {
            // Konec dosyp√°n√≠
            // Konec dosyp√°n√≠
            clearInterval(gameState.refillInterval);
            gameState.refillInterval = null;
            gameState.isRefilling = false;
            
            // Povolit tlaƒç√≠tko +
            addButton.disabled = false;
            addButton.style.opacity = '1';
            addButton.style.cursor = 'pointer';
            
            console.log("Dosyp√°n√≠ dokonƒçeno - spou≈°t√≠m ƒçasom√≠ru");
            
            // Spus≈• ƒçasom√≠ru
            startTimer();
        }
    }, 100); // 0.1 sekundy mezi panely
}
 
/**
 * Animuje splnƒõn√≠ c√≠le - panel na m≈ô√≠≈æce zesvƒõtl√≠, zmiz√≠, objev√≠ se v c√≠li
 * @param {number} gridIndex - Pozice panelu na m≈ô√≠≈æce
 * @param {number} targetIndex - Index c√≠lov√©ho panelu (0-3)
 */
function animateTargetCompletion(gridIndex, targetIndex) {
    console.log(`üé¨ Animace splnƒõn√≠: m≈ô√≠≈æka[${gridIndex}] ‚Üí c√≠l[${targetIndex}]`);
    
    const gridCell = document.querySelector(`[data-index="${gridIndex}"]`);
    if (!gridCell) {
        console.error(`‚ùå gridCell nenalezen pro index ${gridIndex}`);
        return;
    }
    console.log(`‚úÖ gridCell nalezen:`, gridCell);
    
    const panelElement = gridCell.querySelector('.led-panel');
    if (!panelElement) {
        console.error(`‚ùå panelElement nenalezen v gridCell`);
        return;
    }
    console.log(`‚úÖ panelElement nalezen:`, panelElement);
    
    // Zak√°zat interakci s t√≠mto panelem
    panelElement.classList.add('panel-non-interactive');
    
    // F√ÅZE 1: Zesvƒõtlen√≠ (0.0s - 0.2s)
    panelElement.classList.add('panel-brightening');
    console.log(`üé® P≈ôid√°na t≈ô√≠da panel-brightening, classList:`, panelElement.classList);
    
    setTimeout(() => {
        // F√ÅZE 2: Mizen√≠ (0.2s - 0.4s)
        panelElement.classList.add('panel-fading');
        console.log(`üé® P≈ôid√°na t≈ô√≠da panel-fading, classList:`, panelElement.classList);
        
        setTimeout(() => {
            console.log(`‚è∞ Timeout 2 spu≈°tƒõn - po 0.4s celkem`);
            console.log(`  gameState.grid[${gridIndex}] p≈ôed null:`, gameState.grid[gridIndex]);
            
            // F√ÅZE 3: Zmizen√≠ z m≈ô√≠≈æky a p≈ôesun do c√≠le (0.4s)
            gameState.grid[gridIndex] = null;
            renderGrid();
            
            // Oznaƒç c√≠l jako splnƒõn√Ω
            gameState.completedTargets[targetIndex] = true;
            
            console.log(`  Vol√°m animateTargetPanelAppearance(${targetIndex})`);
            
            // Vykresli c√≠lov√Ω ≈ô√°dek s animac√≠
            animateTargetPanelAppearance(targetIndex);
            
            // Zkontroluj v√≠tƒõzstv√≠ a refill A≈Ω PO dokonƒçen√≠ animace goal panelu (0.2s)
            setTimeout(() => {
                checkVictory();
                
                // Reset ƒçasom√≠ry POUZE pokud nebyla v√Ωhra (hra pokraƒçuje)
                const allCompleted = gameState.completedTargets.every(completed => completed === true);
                if (!allCompleted) {
                    resetTimer();
                }
                
                checkAndRefillGrid();
            }, 200); // Poƒçkej na dokonƒçen√≠ animace goal panelu
            
        }, 100); // Po 0.2s mizen√≠
        
    }, 100); // Po 0.2s zesvƒõtlen√≠
}

/**
 * Animuje objeven√≠ panelu v c√≠lov√©m ≈ô√°dku
 * @param {number} targetIndex - Index c√≠lov√©ho panelu (0-3)
 */
function animateTargetPanelAppearance(targetIndex) {
    console.log(`üéØ animateTargetPanelAppearance SPU≈†TƒöN pro targetIndex=${targetIndex}`);
    
    const targetRow = document.getElementById('target-row');
    console.log(`  targetRow:`, targetRow);
    
    const targetCells = targetRow.querySelectorAll('.target-panel');
    console.log(`  targetCells.length:`, targetCells.length);
    
    const targetCell = targetCells[targetIndex];
    console.log(`  targetCell[${targetIndex}]:`, targetCell);
    
    if (!targetCell) return;
    
    // Vyƒçisti bu≈àku
    targetCell.innerHTML = '';
    
    // Vytvo≈ô panel s b√≠l√Ωm filtrem
    const panelValue = gameState.targetPanels[targetIndex];
    const panelElement = createPanelElement(panelValue);
    panelElement.classList.add('target-panel-appearing');
    targetCell.appendChild(panelElement);
    
    // Po mal√©m delay odeber b√≠l√Ω filtr (trigger transition)
    setTimeout(() => {
        panelElement.classList.remove('target-panel-appearing');
        panelElement.classList.add('target-panel-normal');
    }, 10); // Mal√Ω delay pro trigger transition
}
 
 
 // ========== KONTROLA C√çL≈Æ ==========

/**
 * Zkontroluje, zda panel odpov√≠d√° nƒõjak√©mu c√≠lov√©mu panelu
 * @param {number} gridIndex - Pozice v m≈ô√≠≈æce
 */
function checkTargetMatch(gridIndex) {
    const panelValue = gameState.grid[gridIndex];
    
    if (panelValue === null) {
        return false; // ≈Ω√°dn√Ω panel na t√©to pozici
    }
    
    // Projdi v≈°echny c√≠lov√© panely
    for (let i = 0; i < gameState.targetPanels.length; i++) {
        const targetPanel = gameState.targetPanels[i];
        
        // Pokud panel odpov√≠d√° c√≠li A tento c√≠l je≈°tƒõ nen√≠ splnƒõn√Ω
        if (panelValue === targetPanel && !gameState.completedTargets[i]) {
            console.log(`‚úÖ Panel na pozici ${gridIndex} odpov√≠d√° c√≠li ${i}!`);
            
            // Spus≈• animaci m√≠sto okam≈æit√©ho zmizen√≠
            animateTargetCompletion(gridIndex, i);
            
            return true; // Na≈°li jsme shodu
        }
    }
    
    return false; // ≈Ω√°dn√° shoda
}


/**
 * Animace p≈ôechodu mezi levely
 * @param {Function} callback - Funkce kter√° se zavol√° po animaci
 */
function playLevelTransition(callback) {
    const transition = document.getElementById('level-transition');
    const addButton = document.getElementById('add-button');
    const pauseButton = document.getElementById('pause-button');
    const gridElement = document.getElementById('game-grid');
    
    // Zobraz overlay
    transition.style.display = 'block';
    
    // Skryj tlaƒç√≠tko +, pause, ƒçasom√≠ru a m≈ô√≠≈æku
    addButton.style.display = 'none';
    pauseButton.style.display = 'none';
    gridElement.style.display = 'none';
    
    // Fade in (0.3s)
    setTimeout(() => {
        transition.classList.add('fade-in');
    }, 10);
    
    // Po 0.3s fade in + 1s ƒçek√°n√≠ = 1.3s ‚Üí zaƒçni fade out
    setTimeout(() => {
        transition.classList.remove('fade-in');
        
        // Po fade out (0.3s) ‚Üí ukonƒçen√≠ celkem po 1.6s
        setTimeout(() => {
            // Skryj overlay
            transition.style.display = 'none';
            
            // Zobraz zpƒõt UI
            addButton.style.display = 'block';
            pauseButton.style.display = 'block';
           
            gridElement.style.display = 'grid';
            
            // Zavolej callback (naƒçten√≠ nov√©ho levelu)
            if (callback) callback();
        }, 300); // Fade out trv√° 0.3s
    }, 1300); // Fade in (0.3s) + zobrazen√≠ (1s)
}

/**
 * Zkontroluje, zda hr√°ƒç vyhr√°l (v≈°echny 4 c√≠le splnƒõny)
 */
function checkVictory() {
    const allCompleted = gameState.completedTargets.every(completed => completed === true);
    
    if (allCompleted) {
    stopTimer(); // Zastav ƒçasom√≠ru
    
    console.log("üéâ V√çTƒöZSTV√ç! Level dokonƒçen!");
    
    // Zkontroluj, zda existuje dal≈°√≠ level
    const nextLevelNumber = gameState.level + 1;
    const nextLevelExists = LEVELS.find(l => l.levelNumber === nextLevelNumber);
    
    if (nextLevelExists) {
        // Ulo≈æ hru P≈òED p≈ôechodovou animac√≠
        saveGame(nextLevelNumber);
        
        // Existuje dal≈°√≠ level - spus≈• p≈ôechodovou animaci
        playLevelTransition(() => {
            initLevel(nextLevelNumber);
        });
    } else {
        // Byl to posledn√≠ level
        console.log("üéâ Gratulujeme! Dokonƒçili jste v≈°echny levely!");
        showVictoryOverlay();
		}
	}
}
 
function handlePanelClick(gridIndex) {
	// Bƒõhem dosyp√°n√≠ nelze klikat
    if (gameState.isRefilling) {
        return;
    }
    
	// V levelu 1 je flipov√°n√≠ zak√°z√°no (pokud nebyl vidƒõn tut01)
	if (gameState.level === 1 && !isTutorialSeen('tut01')) {
    console.log("üö´ Flipov√°n√≠ v levelu 1 zak√°z√°no");
    return;
	}
    
    // Zkontroluj, zda na pozici je panel
    if (gameState.grid[gridIndex] === null) {
        return;
    }
    
    // Zkamenƒõl√© panely nelze flipovat
    if (isPetrified(gridIndex)) {
        console.log("üíé Zkamenƒõl√Ω panel nelze flipovat");
        return;
    }
    
    // Proveƒè NOT operaci
    const oldValue = gameState.grid[gridIndex];
    const newValue = notOperation(oldValue);
    
    console.log(`Kliknut√≠ na pozici ${gridIndex}:`);
    console.log(`  P≈Øvodn√≠: ${oldValue.toString(2).padStart(7, '0')}`);
    console.log(`  Nov√°:    ${newValue.toString(2).padStart(7, '0')}`);
    
    // Uprav stav a p≈ôekresli (panel dostane novou vizu√°ln√≠ podobu)
    gameState.grid[gridIndex] = newValue;
    renderGrid();
    
    // Zkontroluj, zda panel odpov√≠d√° nƒõkter√©mu c√≠li (najde novƒõ vykreslen√Ω element)
    checkTargetMatch(gridIndex);
    
    // Zkontroluj, zda nevznikla osmiƒçka
    checkAndPetrifyEight(gridIndex);
    
}

// ========== ZKAMENƒöL√â OSMIƒåKY ==========

/**
 * Zkontroluje, zda panel na dan√© pozici je osmiƒçka a zkamen√≠ ji, pokud nen√≠ pot≈ôeba
 * @param {number} gridIndex - Pozice v m≈ô√≠≈æce
 */
function checkAndPetrifyEight(gridIndex) {
    const panelValue = gameState.grid[gridIndex];
    
    // Zkontroluj, zda je to osmiƒçka (v≈°ech 7 segment≈Ø)
    if (panelValue === 0b1111111) {
        // Zjisti, kolik osmiƒçek je v c√≠lov√Ωch panelech
        const eightTargetIndices = [];
        gameState.targetPanels.forEach((target, index) => {
            if (target === 0b1111111) {
                eightTargetIndices.push(index);
            }
        });
        
        // Zjisti, kolik z tƒõchto osmiƒçek je NESPLNƒöN√ùCH
        const uncompletedEightCount = eightTargetIndices.filter(index => 
            !gameState.completedTargets[index]
        ).length;
        
        // Pokud nen√≠ ≈æ√°dn√° nesplnƒõn√° osmiƒçka v c√≠lech, zkame≈à tuto osmiƒçku
        if (uncompletedEightCount === 0 && !gameState.petrifiedPositions.includes(gridIndex)) {
            gameState.petrifiedPositions.push(gridIndex);
            saveGame(gameState.level); // Ulo≈æ aktu√°ln√≠ stav s novou zkamenƒõlou osmiƒçkou
            
            // Zobraz tutori√°l o zkamenƒõl√© osmiƒçce (500ms po zkamenƒõn√≠)
			setTimeout(() => {
			showTutorial('tut04');
			}, 500);
            
            console.log(`üíé Osmiƒçka na pozici ${gridIndex} zkamenƒõl√° (nadbyteƒçn√°)!`);
            renderGrid();
        }
    }
}

/**
 * Zkontroluje, zda je pozice zkamenƒõl√°
 * @param {number} gridIndex - Pozice v m≈ô√≠≈æce
 * @returns {boolean}
 */
function isPetrified(gridIndex) {
    return gameState.petrifiedPositions.includes(gridIndex);
}

/**
 * P≈ôipoj√≠ event listeners na v≈°echny bu≈àky m≈ô√≠≈æky
 */
/**
 * P≈ôipoj√≠ event listeners na v≈°echny bu≈àky m≈ô√≠≈æky
 */
function attachGridListeners() {
    const cells = document.querySelectorAll('.grid-cell');
    cells.forEach(cell => {
        const index = parseInt(cell.dataset.index);
        
        // Stav pro detekci kliknut√≠ vs. drag na mobilu
        let touchStartTime = 0;
        let touchMoved = false;
        let touchStartPos = { x: 0, y: 0 };
        
        // KLIKNUT√ç (NOT operace) - pouze pokud NETAH√ÅME
        cell.addEventListener('click', (e) => {
            if (!dragState.isDragging) {
                handlePanelClick(index);
            }
        });
        
        // DRAG START - mousedown
        cell.addEventListener('mousedown', (e) => {
            handleDragStart(index, e);
        });
        
        // TOUCH START - sleduj ƒças a pohyb
        cell.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            touchMoved = false;
            touchStartPos.x = e.touches[0].clientX;
            touchStartPos.y = e.touches[0].clientY;
            
            // Spus≈• drag start (pro p≈ô√≠pad ≈æe to bude drag)
            handleDragStart(index, e);
        }, { passive: false });
        
        // TOUCH MOVE - oznaƒç ≈æe se h√Ωbe
        cell.addEventListener('touchmove', (e) => {
            const deltaX = Math.abs(e.touches[0].clientX - touchStartPos.x);
            const deltaY = Math.abs(e.touches[0].clientY - touchStartPos.y);
            
            if (deltaX > 5 || deltaY > 5) {
                touchMoved = true;
            }
        }, { passive: true });
        
        // TOUCH END - rozhodni jestli to bylo kliknut√≠ nebo drag
        cell.addEventListener('touchend', (e) => {
            const touchDuration = Date.now() - touchStartTime;
            
            // Kr√°tk√Ω dotyk BEZ pohybu = kliknut√≠
            if (!touchMoved && touchDuration < 300 && !dragState.hasMovedEnough) {
                e.preventDefault();
                
                // Zru≈° drag state
                dragState.isDragging = false;
                dragState.draggedIndex = null;
                dragState.draggedValue = null;
                
                // Zavolej kliknut√≠
                handlePanelClick(index);
            }
        });
    });
}

// Glob√°ln√≠ listenery pro DRAG MOVE a DRAG END
document.addEventListener('mousemove', handleDragMove);
document.addEventListener('mouseup', handleDragEnd);
document.addEventListener('touchmove', handleDragMove, { passive: false });
document.addEventListener('touchend', handleDragEnd, { passive: false });

console.log("Drag & Drop ud√°losti napojeny");

// Uprav√≠me renderGrid() aby po ka≈æd√©m p≈ôekreslen√≠ p≈ôipojila listenery
// Najdi funkci renderGrid() a na jej√≠m KONCI (p≈ôed posledn√≠ }) p≈ôidej: 
 
// ========== DRAG & DROP (OR OPERACE) ==========

let dragState = {
    isDragging: false,
    draggedIndex: null,
    draggedValue: null,
    ghostElement: null,
    startX: 0,           // Poƒç√°teƒçn√≠ pozice X
    startY: 0,           // Poƒç√°teƒçn√≠ pozice Y
    hasMovedEnough: false // Zda u≈æ se pohnul dostateƒçnƒõ
};

/**
 * Zaƒç√°tek ta≈æen√≠ (mousedown / touchstart)
 * @param {number} gridIndex - Index pozice v m≈ô√≠≈æce
 * @param {Event} event - Event object
 */
function handleDragStart(gridIndex, event) {
	
	// Bƒõhem dosyp√°n√≠ nelze dragovat
    if (gameState.isRefilling) {
        return;
    }
	
    // Zkontroluj, zda na pozici je panel
    if (gameState.grid[gridIndex] === null) {
        return;
    }
    
    // Zkamenƒõl√© panely nelze dragovat
    if (isPetrified(gridIndex)) {
        console.log("üíé Zkamenƒõl√Ω panel nelze dragovat");
        return;
    }
    
    event.preventDefault();
    
    dragState.isDragging = true;
    dragState.draggedIndex = gridIndex;
    dragState.draggedValue = gameState.grid[gridIndex];
    dragState.hasMovedEnough = false;
    
    // Ulo≈æ poƒç√°teƒçn√≠ pozici
    dragState.startX = event.clientX || (event.touches && event.touches[0].clientX);
    dragState.startY = event.clientY || (event.touches && event.touches[0].clientY);
    
    console.log(`Zaƒç√°tek ta≈æen√≠ z pozice ${gridIndex}`);
    
    // Ghost se vytvo≈ô√≠ a≈æ p≈ôi pohybu
}

/**
 * Pohyb bƒõhem ta≈æen√≠ (mousemove / touchmove)
 * @param {Event} event - Event object
 */
function handleDragMove(event) {
    if (!dragState.isDragging) return;
    
    event.preventDefault();
    
    const x = event.clientX || (event.touches && event.touches[0].clientX);
    const y = event.clientY || (event.touches && event.touches[0].clientY);
    
    // Pokud je≈°tƒõ nen√≠ ghost vytvo≈ôen√Ω, zkontroluj, zda se pohnul dostateƒçnƒõ
    if (!dragState.hasMovedEnough) {
        const dx = x - dragState.startX;
        const dy = y - dragState.startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const DRAG_THRESHOLD = 10; // 10 pixel≈Ø minim√°ln√≠ pohyb
        
        if (distance >= DRAG_THRESHOLD) {
            dragState.hasMovedEnough = true;
            createDragGhost(event); // Teprve teƒè vytvo≈ô ghost
        }
    } else {
        // Ghost u≈æ existuje, aktualizuj jeho pozici
        updateDragGhost(event);
    }
}

/**
 * Konec ta≈æen√≠ (mouseup / touchend)
 * @param {Event} event - Event object
 */
function handleDragEnd(event) {
    if (!dragState.isDragging) return;
    
    event.preventDefault();
    
    // Najdi, na kterou bu≈àku bylo upu≈°tƒõno
    const dropIndex = getDropTarget(event);
    
    if (dropIndex !== null && dropIndex !== dragState.draggedIndex) {
        console.log(`Drop na pozici ${dropIndex}`);
        performOrOperation(dragState.draggedIndex, dropIndex);
    } else {
        console.log("Drop mimo nebo na stejnou pozici - zru≈°eno");
    }
    
// Vyƒçisti drag state
    removeDragGhost();
    dragState.isDragging = false;
    dragState.draggedIndex = null;
    dragState.draggedValue = null;
    dragState.hasMovedEnough = false;
    dragState.startX = 0;
    dragState.startY = 0;
}

console.log("Drag & Drop syst√©m p≈ôipraven");

// ========== DRAG & DROP: POMOCN√â FUNKCE ==========

/**
 * Vytvo≈ô√≠ ghost element (vizu√°ln√≠ kopie ta≈æen√©ho panelu)
 * @param {Event} event - Event object
 */
function createDragGhost(event) {
    const ghost = createPanelElement(dragState.draggedValue);
    ghost.id = 'drag-ghost';
    ghost.style.position = 'fixed';
ghost.style.width = '78px'; // 60px * 1.3 = 78px
    ghost.style.transform = 'scale(1.3)';
    ghost.style.pointerEvents = 'none';
    ghost.style.opacity = '0.7';
    ghost.style.zIndex = '1000';
    
    document.body.appendChild(ghost);
    dragState.ghostElement = ghost;
    
    updateDragGhost(event);
}

/**
 * Aktualizuje pozici ghost elementu
 * @param {Event} event - Event object
 */
function updateDragGhost(event) {
    if (!dragState.ghostElement) return;
    
    const x = event.clientX || (event.touches && event.touches[0].clientX);
    const y = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (x !== undefined && y !== undefined) {
        dragState.ghostElement.style.left = (x - 39) + 'px'; // -39 = polovina zvƒõt≈°en√© ≈°√≠≈ôky (78/2)
        dragState.ghostElement.style.top = (y - 56) + 'px';  // -56 = polovina zvƒõt≈°en√© v√Ω≈°ky (78*100/70/2)
    }
}

/**
 * Odstran√≠ ghost element
 */
function removeDragGhost() {
    if (dragState.ghostElement) {
        dragState.ghostElement.remove();
        dragState.ghostElement = null;
    }
}

/**
 * Zjist√≠, na kterou bu≈àku m≈ô√≠≈æky bylo upu≈°tƒõno
 * @param {Event} event - Event object
 * @returns {number|null} - Index bu≈àky nebo null
 */
function getDropTarget(event) {
    const x = event.clientX || (event.changedTouches && event.changedTouches[0].clientX);
    const y = event.clientY || (event.changedTouches && event.changedTouches[0].clientY);
    
    if (x === undefined || y === undefined) return null;
    
    // Najdi element na tƒõchto sou≈ôadnic√≠ch
    const element = document.elementFromPoint(x, y);
    
    // Zjisti, zda je to bu≈àka m≈ô√≠≈æky
    const cell = element?.closest('.grid-cell');
    if (cell && cell.dataset.index) {
        return parseInt(cell.dataset.index);
    }
    
    return null;
}

/**
 * Provede OR operaci mezi dvƒõma panely
 * @param {number} sourceIndex - Odkud tah√°me
 * @param {number} targetIndex - Kam dropujeme
 */
function performOrOperation(sourceIndex, targetIndex) {
	
// Nelze dropovat na zkamenƒõl√Ω panel
    if (isPetrified(targetIndex)) {
        console.log("üíé Nelze dropovat na zkamenƒõl√Ω panel");
        // Panel se vr√°t√≠ zpƒõt - nic se nestane
        renderGrid();
        return;
    }
    
    const sourceValue = gameState.grid[sourceIndex];
    const targetValue = gameState.grid[targetIndex];
    
    // Pokud je c√≠l pr√°zdn√Ω, prostƒõ p≈ôesu≈à panel
    if (targetValue === null) {
        gameState.grid[targetIndex] = sourceValue;
        gameState.grid[sourceIndex] = null;
        console.log(`Panel p≈ôesunut z ${sourceIndex} na ${targetIndex}`);
    } else {
        // Proveƒè OR operaci
        const result = orOperation(sourceValue, targetValue);
        gameState.grid[targetIndex] = result;
        gameState.grid[sourceIndex] = null;
        
        console.log(`OR operace: ${sourceIndex} + ${targetIndex}`);
        console.log(`  Panel A: ${sourceValue.toString(2).padStart(7, '0')}`);
        console.log(`  Panel B: ${targetValue.toString(2).padStart(7, '0')}`);
        console.log(`  V√Ωsledek: ${result.toString(2).padStart(7, '0')}`);
    }
    
    // P≈ôekresli m≈ô√≠≈æku (zobraz√≠ v√Ωsledek operace)
    renderGrid();
    
    // Zkontroluj, zda panel odpov√≠d√° nƒõkter√©mu c√≠li
    checkTargetMatch(targetIndex);
    
    // Zkontroluj, zda nevznikla osmiƒçka na c√≠lov√© pozici
    checkAndPetrifyEight(targetIndex);
    
    // Zkontroluj, zda nen√≠ plocha pr√°zdn√°
    checkAndRefillGrid();
}

console.log("Drag & Drop pomocn√© funkce p≈ôipraveny");

// ========== GENEROV√ÅN√ç POOL PANEL≈Æ ==========

/**
 * Rozdƒõl√≠ segmenty na N podmno≈æin (n√°hodn√© rozdƒõlen√≠)
 * @param {number} segmentMask - P≈Øvodn√≠ panel
 * @param {number} parts - Poƒçet ƒç√°st√≠ (2 nebo 3)
 * @returns {Array<number>} - Pole rozdƒõlen√Ωch panel≈Ø
 */
function splitSegments(segmentMask, parts) {
    // Zjisti, kter√© segmenty jsou rozsv√≠cen√©
    const litSegments = [];
    for (let i = 0; i < 7; i++) {
        if (segmentMask & (1 << i)) {
            litSegments.push(i);
        }
    }
    
    // Pokud je segment≈Ø m√©nƒõ ne≈æ parts, nelze rozdƒõlit
    if (litSegments.length < parts) {
        console.warn(`Nelze rozdƒõlit ${litSegments.length} segment≈Ø na ${parts} ƒç√°st√≠`);
        return [segmentMask]; // Vr√°t√≠ p≈Øvodn√≠ panel
    }
    
    // N√°hodn√© rozdƒõlen√≠ segment≈Ø do ƒç√°st√≠
    const subsets = Array(parts).fill(0).map(() => []);
    
    // Ka≈æd√° ƒç√°st mus√≠ m√≠t alespo≈à 1 segment
    for (let i = 0; i < parts; i++) {
        const randomIndex = Math.floor(Math.random() * litSegments.length);
        subsets[i].push(litSegments.splice(randomIndex, 1)[0]);
    }
    
    // Zbyl√© segmenty rozdƒõl√≠ n√°hodnƒõ
    litSegments.forEach(seg => {
        const randomPart = Math.floor(Math.random() * parts);
        subsets[randomPart].push(seg);
    });
    
    // P≈ôeveƒè zpƒõt na bin√°rn√≠ masky
    return subsets.map(subset => {
        let mask = 0;
        subset.forEach(bitIndex => {
            mask |= (1 << bitIndex);
        });
        return mask;
    });
}

// TEST rozdƒõlen√≠
// TEST rozdƒõlen√≠
console.log("=== TEST ROZDƒöLEN√ç SEGMENT≈Æ ===");
const testPanelSplit = DIGITS[8]; // 0b1111111 (v≈°echny segmenty)
console.log("P≈Øvodn√≠ panel (8):", testPanelSplit.toString(2).padStart(7, '0'));

const split2 = splitSegments(testPanelSplit, 2);

console.log("Rozdƒõleno na 2 ƒç√°sti:");
split2.forEach((part, i) => {
    console.log(`  ƒå√°st ${i+1}: ${part.toString(2).padStart(7, '0')}`);
});

const split3 = splitSegments(testPanelSplit, 3);
console.log("Rozdƒõleno na 3 ƒç√°sti:");
split3.forEach((part, i) => {
    console.log(`  ƒå√°st ${i+1}: ${part.toString(2).padStart(7, '0')}`);
});


// ========== GENEROV√ÅN√ç POOL: OPERACE A-G ==========

/**
 * Aplikuje operaci na c√≠lov√Ω panel a vr√°t√≠ pole v√Ωsledn√Ωch panel≈Ø
 * @param {number} targetPanel - C√≠lov√Ω panel (7-bit)
 * @param {string} operation - Operace ('a', 'b', 'c', 'd', 'e', 'f', 'g')
 * @returns {Array<number>} - Pole vygenerovan√Ωch panel≈Ø
 */
function applyPoolOperation(targetPanel, operation) {
    let result = [];
    
    switch(operation) {
        case 'a': // Invertovat
            result = [notOperation(targetPanel)];
            break;
            
        case 'b': // Rozdƒõlit na 2 ƒç√°sti
            result = splitSegments(targetPanel, 2);
            break;
            
        case 'c': // Rozdƒõlit na 3 ƒç√°sti
            result = splitSegments(targetPanel, 3);
            break;
            
        case 'd': // Invertovat + rozdƒõlit na 2
            const inverted_d = notOperation(targetPanel);
            result = splitSegments(inverted_d, 2);
            break;
            
        case 'e': // Invertovat + rozdƒõlit na 3
            const inverted_e = notOperation(targetPanel);
            result = splitSegments(inverted_e, 3);
            break;
            
        case 'f': // Rozdƒõlit na 2 + n√°hodnƒõ invertovat nƒõkter√© ƒç√°sti
            const parts_f = splitSegments(targetPanel, 2);
            result = parts_f.map(part => {
                return Math.random() < 0.5 ? notOperation(part) : part;
            });
            break;
            
        case 'g': // Rozdƒõlit na 3 + n√°hodnƒõ invertovat nƒõkter√© ƒç√°sti
            const parts_g = splitSegments(targetPanel, 3);
            result = parts_g.map(part => {
                return Math.random() < 0.5 ? notOperation(part) : part;
            });
            break;
            
        default:
            console.error('Nezn√°m√° operace:', operation);
            result = [targetPanel];
    }
    
    return result;
}

// TEST operac√≠
console.log("=== TEST OPERAC√ç A-G ===");
const testOpsPanel = DIGITS[2]; // ƒå√≠slice 2
console.log("C√≠lov√Ω panel (2):", testOpsPanel.toString(2).padStart(7, '0'));

['a', 'b', 'c', 'd', 'e'].forEach(op => {
    const panels = applyPoolOperation(testOpsPanel, op);
    console.log(`Operace ${op}:`, panels.map(p => p.toString(2).padStart(7, '0')));
});

/**
 * Vygeneruje n√°hodn√Ω panel, kter√Ω nen√≠ kolizn√≠ s c√≠lov√Ωmi panely
 * N√°hodn√Ω panel m√° 1-6 segment≈Ø a nen√≠ c√≠lem ani jeho inverz√≠
 * @returns {number} - N√°hodn√Ω panel (7-bit)
 */
function generateRandomPanel() {
    const maxAttempts = 100;
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        // N√°hodn√Ω poƒçet segment≈Ø (1-6, ne 0 ani 7)
        const segmentCount = Math.floor(Math.random() * 6) + 1;
        
        // N√°hodnƒõ vyber kter√© segmenty budou sv√≠tit
        let randomPanel = 0;
        const usedSegments = new Set();
        
        while (usedSegments.size < segmentCount) {
            const segment = Math.floor(Math.random() * 7);
            usedSegments.add(segment);
        }
        
        usedSegments.forEach(seg => {
            randomPanel |= (1 << seg);
        });
        
        // Zkontroluj, zda NEN√ç kolizn√≠
        const isTarget = gameState.targetPanels.includes(randomPanel);
        const isInverted = gameState.targetPanels.includes(notOperation(randomPanel));
        
        if (!isTarget && !isInverted) {
            console.log(`‚úÖ Vygenerov√°n n√°hodn√Ω panel: ${randomPanel.toString(2).padStart(7, '0')}`);
            return randomPanel;
        }
    }
    
    // Failsafe
    console.warn(`‚ö†Ô∏è Nepoda≈ôilo se vygenerovat n√°hodn√Ω panel - pou≈æit fallback`);
    return 0b0010010;
}

// ========== GENEROV√ÅN√ç CEL√âHO POOLU ==========

/**
 * Vygeneruje pool panel≈Ø pro aktu√°ln√≠ level
 * @param {Array<string>} allowedOperations - Povolen√© operace (nap≈ô. ['b', 'c', 'd'])
 * @returns {Array<number>} - Zam√≠chan√Ω pool panel≈Ø
 */
/**
 * Vygeneruje pool panel≈Ø pro aktu√°ln√≠ level
 * @param {Array<string>} allowedOperations - Povolen√© operace (nap≈ô. ['b', 'c', 'd'])
 * @returns {Array<number>} - Zam√≠chan√Ω pool panel≈Ø
 */
function generatePool(allowedOperations) {
    let pool = [];
    
    // Pro ka≈æd√Ω ze 4 c√≠lov√Ωch panel≈Ø (ale jen nesplnƒõn√©)
    gameState.targetPanels.forEach((targetPanel, index) => {
        // P≈ôeskoƒç splnƒõn√© c√≠le
        if (gameState.completedTargets[index]) {
            console.log(`C√≠l ${index} u≈æ je splnƒõn√Ω - nep≈ôid√°v√°m do poolu`);
            return;
        }
        let panels = [];
        let attempts = 0;
        const maxAttempts = 100; // Ochrana proti nekoneƒçn√© smyƒçce
        
        // Opakuj, dokud nevzniknou panely bez p≈ô√≠m√© shody s c√≠li
        do {
            // Vyber n√°hodnou povolenou operaci
            const randomOp = allowedOperations[Math.floor(Math.random() * allowedOperations.length)];
            
            // Aplikuj operaci
            panels = applyPoolOperation(targetPanel, randomOp);
            
            attempts++;
            
            // Zkontroluj NOT kolizi - pokud operace 'a' NEN√ç povolena A jsme od levelu 5
            const notAllowed = !allowedOperations.includes('a');
            const checkNotCollision = notAllowed && gameState.level >= 5;
            
            if (checkNotCollision) {
                // Projdi v≈°echny vygenerovan√© panely
                panels = panels.map(panel => {
                    // Je tento panel NOT(c√≠lov√Ω panel)?
                    const isNotOfTarget = gameState.targetPanels.includes(notOperation(panel));
                    
                    if (isNotOfTarget) {
                        console.log(`C√≠l ${index}: panel ${panel.toString(2).padStart(7, '0')} je NOT(c√≠l) a 'a' nen√≠ povolena - nahrazen n√°hodn√Ωm`);
                        return generateRandomPanel();
                    }
                    return panel;
                });
            }
            
            // Zkontroluj, zda nƒõkter√Ω z panel≈Ø nen√≠ identick√Ω s c√≠lem
            const hasDirectMatch = panels.some(panel => 
                gameState.targetPanels.includes(panel)
            );
            
            if (!hasDirectMatch) {
                // ≈Ω√°dn√° p≈ô√≠m√° shoda - panely jsou OK
                console.log(`C√≠l ${index}: operace '${randomOp}' ‚Üí ${panels.length} panel≈Ø (pokus≈Ø: ${attempts})`);
                break;
                
            } else {
                console.log(`C√≠l ${index}: operace '${randomOp}' vytvo≈ôila v√Ωhern√≠ panel - generuji znovu...`);
            }
            
            if (attempts >= maxAttempts) {
                console.error(`C√≠l ${index}: Nepoda≈ôilo se vygenerovat validn√≠ panely po ${maxAttempts} pokusech!`);
                break;
            }
            
        } while (true);
        
        // P≈ôidej panely do poolu
        pool.push(...panels);
    });
    
    // Zam√≠chej pool (pokud je to povoleno v level datech)
    const levelData = LEVELS.find(l => l.levelNumber === gameState.level);
    const shouldShuffle = levelData?.shufflePool !== false; // Default = true (zam√≠chat)
    
    if (shouldShuffle) {
        shuffleArray(pool);
        console.log(`Pool vygenerov√°n: ${pool.length} panel≈Ø (zam√≠chan√Ω)`);
    } else {
        console.log(`Pool vygenerov√°n: ${pool.length} panel≈Ø (postupn√Ω - tutori√°l)`);
    }
    
    return pool;
}

/**
 * Zam√≠ch√° pole (Fisher-Yates shuffle)
 * @param {Array} array - Pole k zam√≠ch√°n√≠
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

/**
 * Vygeneruje nov√Ω pool podle aktu√°ln√≠ho levelu
 */
function regeneratePool() {
    // Najdi data aktu√°ln√≠ho levelu
    const levelData = LEVELS.find(l => l.levelNumber === gameState.level);
    
    if (!levelData) {
        console.error(`Level ${gameState.level} nenalezen p≈ôi generov√°n√≠ poolu!`);
        return;
    }
    
    console.log(`Generuji nov√Ω pool pro level ${gameState.level} s operacemi: ${levelData.allowedOperations.join(', ')}`);
    
    // Vygeneruj pool s operacemi z levelu
    const allowedOps = levelData.allowedOperations;
    gameState.panelPool = generatePool(allowedOps);
}


// ========== ƒåASOM√çRA ==========

/**
 * Spust√≠ ƒçasom√≠ru
 */
function startTimer() {
    // Pokud je timerDuration 0, ƒçasom√≠ra nebƒõ≈æ√≠
    if (gameState.timerDuration === 0) {
        console.log("‚è∞ ƒåasom√≠ra vypnut√° (timerDuration = 0)");
        return;
    }
    
    // Zastav p≈ô√≠padn√Ω bƒõ≈æ√≠c√≠ timer
    stopTimer();
    
    // Nastav plnou ƒçasom√≠ru
    gameState.timerRemaining = gameState.timerDuration;
    updateTimerBar();
    
    // Spus≈• interval (aktualizace ka≈æd√Ωch 100ms)
    gameState.timerInterval = setInterval(() => {
        gameState.timerRemaining -= 100;
        
        // Aktualizuj vizu√°ln√≠ prou≈æek
        updateTimerBar();
        
        // Pokud ƒças vypr≈°el
        if (gameState.timerRemaining <= 0) {
            console.log("‚è∞ ƒåas vypr≈°el - p≈ôid√°v√°m panel");
            handleAddButton(); // Automaticky p≈ôid√° panel
            startTimer(); // Restart timeru
        }
    }, 100);
    
    console.log("ƒåasom√≠ra spu≈°tƒõna");
}

/**
 * Zastav√≠ ƒçasom√≠ru
 */
function stopTimer() {
    if (gameState.timerInterval) {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
    }
}

/**
 * Pozastav√≠ ƒçasom√≠ru (bez resetu)
 */
function pauseTimer() {
    if (gameState.timerInterval) {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
        console.log("‚è∏ ƒåasom√≠ra pozastavena");
    }
}

/**
 * Obnov√≠ ƒçasom√≠ru (pokraƒçuje od pozastaven√©ho stavu)
 */
function resumeTimer() {
    // Pokud je timerDuration 0, ƒçasom√≠ra nebƒõ≈æ√≠ - nic neobnovuj
    if (gameState.timerDuration === 0) {
        console.log("‚è∞ ƒåasom√≠ra vypnut√° - resume ignorov√°no");
        return;
    }
    
    if (gameState.timerInterval) {
        return; // Timer u≈æ bƒõ≈æ√≠
    }
    
    gameState.timerInterval = setInterval(() => {
        gameState.timerRemaining -= 100;
        updateTimerBar();
        
        if (gameState.timerRemaining <= 0) {
            console.log("‚è∞ ƒåas vypr≈°el - p≈ôid√°v√°m panel");
            handleAddButton();
            startTimer();
        }
    }, 100);
    
    console.log("‚ñ∂ ƒåasom√≠ra obnovena");
}

/**
 * Aktualizuje vizu√°ln√≠ prou≈æek ƒçasom√≠ry
 */
function updateTimerBar() {
    // Invertuj procenta - timer postupnƒõ NAR≈ÆST√Å zleva doprava
    const elapsed = gameState.timerDuration - gameState.timerRemaining;
    const percentage = (elapsed / gameState.timerDuration) * 100;
    
    // Nastav ≈°√≠≈ôku modr√©ho pozad√≠ tlaƒç√≠tka +
    const addButton = document.getElementById('add-button');
    addButton.style.setProperty('--timer-width', percentage + '%');
}

/**
 * Reset timeru p≈ôi manu√°ln√≠m p≈ôid√°n√≠ panelu
 */
function resetTimer() {
    startTimer();
}

// ========== PAUSE FUNKCIONALITA ==========

const pauseButton = document.getElementById('pause-button');
const pauseOverlay = document.getElementById('pause-overlay');

pauseOverlay.addEventListener('click', (e) => {
    const now = Date.now();
    
    if (now < pauseUnlockTime) {
        console.log("‚è∏ P≈ô√≠li≈° rychl√© kliknut√≠ - ignorov√°no");
        return;
    }
    
    // Detekce klikac√≠ z√≥ny
    const rect = pauseOverlay.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Lev√Ω horn√≠ roh (1/4 ≈°√≠≈ôky, 1/8 v√Ω≈°ky) - HELP
    if (x <= rect.width / 4 && y <= rect.height / 4) {
        showHelpOverlay('pause-overlay');
    }
    // Prav√Ω horn√≠ roh (posledn√≠ 1/4 ≈°√≠≈ôky, 1/8 v√Ω≈°ky) - RELOAD
    else if (x >= rect.width * 3/4 && y <= rect.height / 4) {
        showNewGameOverlay('pause-overlay');
    }
    // Norm√°ln√≠ klik - odpausovat
    else {
        pauseOverlay.style.display = 'none';
        resumeTimer();
        console.log("‚ñ∂ Hra pokraƒçuje");
    }
});

let pauseUnlockTime = 0;


pauseButton.addEventListener('click', () => {
    // Pozastav ƒçasom√≠ru (BEZ resetu)
    pauseTimer();
    
    // Zobraz overlay
    pauseOverlay.style.display = 'flex';
    
    // Nastav unlock time (1000ms od teƒè)
    pauseUnlockTime = Date.now() + 300;
    
    console.log("‚è∏ Hra pozastavena");
});

console.log("Pause tlaƒç√≠tko p≈ôipraveno");


console.log("ƒåasom√≠ra p≈ôipravena");

// ========== GAME OVER ==========

function showGameOverOverlay() {
    console.log("üíÄ GAME OVER - zobrazuji overlay");
    
    // Cleanup dragu pokud prob√≠h√°
removeDragGhost();
dragState.isDragging = false;
dragState.draggedIndex = null;
dragState.draggedValue = null;
dragState.hasMovedEnough = false;
    
    // Sma≈æ ulo≈æen√Ω stav
    clearSave();
    
    // Zjisti n√°zev levelu (rok)
    const levelData = LEVELS.find(l => l.levelNumber === gameState.level);
    const yearName = levelData ? levelData.displayName : gameState.level.toString();
    
    // Nastav text roku
    const yearDisplay = document.getElementById('year-display');
    yearDisplay.textContent = yearName;
    
    // Zastav v≈°echny intervaly
    stopTimer();
    if (gameState.introInterval) {
        clearInterval(gameState.introInterval);
        gameState.introInterval = null;
    }
    if (gameState.refillInterval) {
        clearInterval(gameState.refillInterval);
        gameState.refillInterval = null;
    }
    
    // Vyƒçisti hern√≠ stav
    gameState.grid = Array(GRID_SIZE * GRID_SIZE).fill(null);
    gameState.completedTargets = [false, false, false, false];
    gameState.petrifiedPositions = [];
    gameState.panelPool = [];
    gameState.isIntroSequence = false;
    gameState.isRefilling = false;
    gameState.level = 1;
    
// Vykresli pr√°zdnou m≈ô√≠≈æku
initGrid();
renderGrid();
    
    // Zobraz game over overlay
    const gameoverOverlay = document.getElementById('gameover-overlay');
    gameoverOverlay.style.display = 'flex';
    
    // Nastav unlock time (300ms ochrana)
    gameoverUnlockTime = Date.now() + 1000;
}

let gameoverUnlockTime = 0;

const gameoverOverlay = document.getElementById('gameover-overlay');

gameoverOverlay.addEventListener('click', () => {
    const now = Date.now();
    
    // Ochrana proti rychl√©mu kliknut√≠
    if (now < gameoverUnlockTime) {
        console.log("üíÄ P≈ô√≠li≈° rychl√© kliknut√≠ - ignorov√°no");
        return;
    }
    
    // Skryj game over overlay
    gameoverOverlay.style.display = 'none';
    
    // Spus≈• hru od zaƒç√°tku
    initLevel(1);
    
    console.log("üîÑ Hra restartov√°na z game over");
});

console.log("Game Over overlay p≈ôipraven");


// ========== VICTORY ==========

function showVictoryOverlay() {
    console.log("üéâ V√çTƒöZSTV√ç - zobrazuji overlay");
    
    // Cleanup dragu pokud prob√≠h√°
removeDragGhost();
dragState.isDragging = false;
dragState.draggedIndex = null;
dragState.draggedValue = null;
dragState.hasMovedEnough = false;
    
    // Sma≈æ ulo≈æen√Ω stav
    clearSave();
    
    // Zastav v≈°echny intervaly
    stopTimer();
    if (gameState.introInterval) {
        clearInterval(gameState.introInterval);
        gameState.introInterval = null;
    }
    if (gameState.refillInterval) {
        clearInterval(gameState.refillInterval);
        gameState.refillInterval = null;
    }
    
    // Vyƒçisti hern√≠ stav
    gameState.grid = Array(GRID_SIZE * GRID_SIZE).fill(null);
    gameState.completedTargets = [false, false, false, false];
    gameState.petrifiedPositions = [];
    gameState.panelPool = [];
    gameState.isIntroSequence = false;
    gameState.isRefilling = false;
    gameState.level = 1;
    
    // Vykresli pr√°zdnou m≈ô√≠≈æku
initGrid();
renderGrid();
    
    // Zobraz victory overlay
    const victoryOverlay = document.getElementById('victory-overlay');
    victoryOverlay.style.display = 'flex';
    
    // Nastav unlock time (300ms ochrana)
    victoryUnlockTime = Date.now() + 1000;
}

let victoryUnlockTime = 0;

const victoryOverlay = document.getElementById('victory-overlay');

victoryOverlay.addEventListener('click', () => {
    const now = Date.now();
    
    // Ochrana proti rychl√©mu kliknut√≠
    if (now < victoryUnlockTime) {
        console.log("üéâ P≈ô√≠li≈° rychl√© kliknut√≠ - ignorov√°no");
        return;
    }
    
    // Skryj victory overlay
    victoryOverlay.style.display = 'none';
    
    // Spus≈• hru od zaƒç√°tku
    initLevel(1);
    
    console.log("üîÑ Hra restartov√°na z victory");
});

console.log("Victory overlay p≈ôipraven");


// ========== HELP OVERLAY ==========

function showHelpOverlay(fromOverlay) {
    console.log(`üìñ Zobrazuji help z overlay: ${fromOverlay}`);
    
    // Ulo≈æ odkud p≈ôi≈°el
    previousOverlay = fromOverlay;
    
    // Skryj p≈Øvodn√≠ overlay
    document.getElementById(fromOverlay).style.display = 'none';
    
    // Zobraz help overlay
    const helpOverlay = document.getElementById('help-overlay');
    helpOverlay.style.display = 'flex';
    
    // Nastav unlock time (1000ms ochrana)
    helpUnlockTime = Date.now() + 300;
}

let helpUnlockTime = 0;

const helpOverlay = document.getElementById('help-overlay');

helpOverlay.addEventListener('click', () => {
    const now = Date.now();
    
    // Ochrana proti rychl√©mu kliknut√≠
    if (now < helpUnlockTime) {
        console.log("üìñ P≈ô√≠li≈° rychl√© kliknut√≠ - ignorov√°no");
        return;
    }
    
    // Skryj help overlay
    helpOverlay.style.display = 'none';
    
    // Vra≈• se na p≈Øvodn√≠ overlay
    if (previousOverlay) {
        const returnOverlay = document.getElementById(previousOverlay);
        returnOverlay.style.display = 'flex';
        
        // Nastav unlock time pro p≈Øvodn√≠ overlay
        if (previousOverlay === 'intro-overlay') {
            introUnlockTime = Date.now() + 300;
        } else if (previousOverlay === 'load-overlay') {
            loadUnlockTime = Date.now() + 300;
        } else if (previousOverlay === 'pause-overlay') {
            pauseUnlockTime = Date.now() + 300;
        }
        
        console.log(`üìñ N√°vrat na overlay: ${previousOverlay}`);
    }
});

console.log("Help overlay p≈ôipraven");


// ========== NEW GAME CONFIRMATION OVERLAY ==========

function showNewGameOverlay(fromOverlay) {
    console.log(`üîÑ Zobrazuji New Game dialog z overlay: ${fromOverlay}`);
    
    // Ulo≈æ odkud p≈ôi≈°el
    previousOverlay = fromOverlay;
    
    // Skryj p≈Øvodn√≠ overlay
    document.getElementById(fromOverlay).style.display = 'none';
    
    // Zobraz newgame overlay
    const newgameOverlay = document.getElementById('newgame-overlay');
    newgameOverlay.style.display = 'flex';
    
    // Nastav unlock time (500ms ochrana)
    newgameUnlockTime = Date.now() + 500;
}

let newgameUnlockTime = 0;

const newgameOverlay = document.getElementById('newgame-overlay');

newgameOverlay.addEventListener('click', (e) => {
    const now = Date.now();
    
    // Ochrana proti rychl√©mu kliknut√≠
    if (now < newgameUnlockTime) {
        console.log("üîÑ P≈ô√≠li≈° rychl√© kliknut√≠ - ignorov√°no");
        return;
    }
    
    // Detekce klikac√≠ z√≥n YES/NO (t≈ôet√≠ ƒçtvrtina shora)
    const rect = newgameOverlay.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // T≈ôet√≠ ƒçtvrtina = y mezi 1/4 a 1/2 v√Ω≈°ky
    if (y < (rect.height / 4)*3 && y >= rect.height / 2) {
        if (x <= rect.width / 2) {
            // YES - lev√° polovina
            console.log("üîÑ YES - Nov√° hra");
            
            // Sma≈æ save
            clearSave();
            
            // Vyƒçisti petrifikovan√© pozice
			gameState.petrifiedPositions = [];
            
            // Skryj newgame overlay
            newgameOverlay.style.display = 'none';
            
            // Spus≈• novou hru
initGrid();
initLevel(1);
            
        } else {
            // NO - prav√° polovina
            console.log("üîÑ NO - N√°vrat");
            
            // Skryj newgame overlay
            newgameOverlay.style.display = 'none';
            
            // Vra≈• se na p≈Øvodn√≠ overlay
            if (previousOverlay) {
                const returnOverlay = document.getElementById(previousOverlay);
                returnOverlay.style.display = 'flex';
                
                // Nastav unlock time pro p≈Øvodn√≠ overlay
                if (previousOverlay === 'load-overlay') {
                    loadUnlockTime = Date.now() + 300;
                } else if (previousOverlay === 'pause-overlay') {
                    pauseUnlockTime = Date.now() + 300;
                }
                
                console.log(`üîÑ N√°vrat na overlay: ${previousOverlay}`);
            }
        }
    }
});

console.log("New Game overlay p≈ôipraven");

// ========== TUTORIAL OVERLAYS ==========

let tutorialUnlockTime = 0;

/**
 * Zobraz√≠ tutori√°lov√Ω overlay (pokud je≈°tƒõ nebyl vidƒõn)
 * @param {string} tutId - ID tutori√°lu ('tut01', 'tut02', 'tut03', 'tut04')
 */
function showTutorial(tutId) {
    // Zkontroluj, zda u≈æ byl tutori√°l vidƒõn
    if (isTutorialSeen(tutId)) {
        console.log(`üìö Tutori√°l ${tutId} ji≈æ byl vidƒõn - p≈ôeskakuji`);
        return;
    }
    
    console.log(`üìö Zobrazuji tutori√°l: ${tutId}`);
    
    // Tut04 pausne ƒçasom√≠ru
    if (tutId === 'tut04') {
        pauseTimer();
    }
    
    // Najdi spr√°vn√Ω element podle typu tutori√°lu
    let elementId;
    if (tutId === 'tut01') elementId = 'tut01-merge';
    else if (tutId === 'tut02') elementId = 'tut02-invert';
    else if (tutId === 'tut03') elementId = 'tut03-add';
    else if (tutId === 'tut04') elementId = 'tut04-shape8';
    
    const tutOverlay = document.getElementById(elementId);
    if (!tutOverlay) {
        console.error(`‚ùå Tutori√°l ${tutId} nenalezen!`);
        return;
    }
    
    tutOverlay.style.display = 'flex';
    
    // Nastav unlock time (1000ms ochrana)
    tutorialUnlockTime = Date.now() + 1000;
}

// Event listenery pro v≈°echny tutori√°ly
const tutorials = [
    { id: 'tut01', elementId: 'tut01-merge' },
    { id: 'tut02', elementId: 'tut02-invert' },
    { id: 'tut03', elementId: 'tut03-add' },
    { id: 'tut04', elementId: 'tut04-shape8' }
];

tutorials.forEach(tut => {
    const tutOverlay = document.getElementById(tut.elementId);
    
    if (tutOverlay) {
        tutOverlay.addEventListener('click', () => {
            const now = Date.now();
            
            // Ochrana proti rychl√©mu kliknut√≠
            if (now < tutorialUnlockTime) {
                console.log(`üìö P≈ô√≠li≈° rychl√© kliknut√≠ - ignorov√°no`);
                return;
            }
            
            // Oznaƒç jako vidƒõn√Ω
            markTutorialSeen(tut.id);
            
            // Skryj tutori√°l
            tutOverlay.style.display = 'none';
            
            // Tut04 obnov√≠ ƒçasom√≠ru
            if (tut.id === 'tut04') {
                resumeTimer();
            }
            
            console.log(`üìö Tutori√°l ${tut.id} zav≈ôen`);
        });
    }
});

console.log("Tutori√°lov√© overlaye p≈ôipraveny");


// ========== LOAD OVERLAY ==========



const loadOverlay = document.getElementById('load-overlay');

loadOverlay.addEventListener('click', (e) => {
    const now = Date.now();
    
    if (now < loadUnlockTime) {
        console.log("üìÇ P≈ô√≠li≈° rychl√© kliknut√≠ - ignorov√°no");
        return;
    }
    
    // Detekce klikac√≠ z√≥ny
    const rect = loadOverlay.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Lev√Ω horn√≠ roh (1/4 ≈°√≠≈ôky, 1/8 v√Ω≈°ky) - HELP
    if (x <= rect.width / 4 && y <= rect.height / 4) {
        showHelpOverlay('load-overlay');
    }
    // Prav√Ω horn√≠ roh (posledn√≠ 1/4 ≈°√≠≈ôky, 1/8 v√Ω≈°ky) - RELOAD
    else if (x >= rect.width * 3/4 && y <= rect.height / 4) {
        showNewGameOverlay('load-overlay');
    }
    // Norm√°ln√≠ klik - naƒç√≠st level
    else {
        loadOverlay.style.display = 'none';
        initLevel(loadedLevel);
        console.log(`üìÇ Hra naƒçtena - spu≈°tƒõn level ${loadedLevel}`);
    }
});

console.log("Load overlay p≈ôipraven");

// ========== INTRO OVERLAY ==========

let introUnlockTime = 0;  // <-- P≈òIDEJ tento ≈ô√°dek

const introOverlay = document.getElementById('intro-overlay');

introOverlay.addEventListener('click', (e) => {
    const now = Date.now();
    
    if (now < introUnlockTime) {
        console.log("üéÆ P≈ô√≠li≈° rychl√© kliknut√≠ - ignorov√°no");
        return;
    }
    
    // Detekce klikac√≠ z√≥ny (lev√Ω horn√≠ roh: 1/4 ≈°√≠≈ôky, 1/8 v√Ω≈°ky)
    const rect = introOverlay.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if (x <= rect.width / 4 && y <= rect.height / 4) {
        // Klik v help z√≥nƒõ
        showHelpOverlay('intro-overlay');
    } else {
        // Norm√°ln√≠ klik - spustit hru
        introOverlay.style.display = 'none';
        initLevel(1);
        console.log("üéÆ Hra spu≈°tƒõna z intro overlay");
    }
});

console.log("Intro overlay p≈ôipraven");

// ========== AUTO-PAUSE P≈òI ZTR√ÅTƒö VISIBILITY ==========

document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Cleanup dragu pokud prob√≠h√°
        removeDragGhost();
        dragState.isDragging = false;
        dragState.draggedIndex = null;
        dragState.draggedValue = null;
        dragState.hasMovedEnough = false;
        
        // Pozastav ƒçasom√≠ru
        pauseTimer();
        
        // Zobraz pause overlay
        const pauseOverlay = document.getElementById('pause-overlay');
        pauseOverlay.style.display = 'flex';
        pauseUnlockTime = Date.now() + 300;
        
        console.log("‚è∏ Auto-pause (ztr√°ta visibility)");
    }
});

console.log("Visibility change listener p≈ôipraven");


    </script>
</body>
</html>
